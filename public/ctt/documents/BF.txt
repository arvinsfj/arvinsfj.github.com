brainfuck分析

数据数组：

0000000000000000000000000.....[10000].....
^
p

代码数组：

++++++++[>+++++++++<-]>.
^
c

上面是bf数据数组默认情况，一个pointer，一个初始化为0的数组，pointer指向数组第一个元素。

其实bf还有一个代码存储数组，专门放置bf代码的。一个指针c，一个存储代码的数组，指针c指向代码的第1条指令。

每条指令执行完成，则指针c位置加1指向下一条指令。除非遇到[或者]指令，则根据p指向的数值是否等于0改变指针c的位置。

> p的位置加1
< p的位置减1

+ p所指向位置的数组元素数值加1
- p所指向位置的数组元素数值减1

. 输出p所指向位置的数组元素的数值
, 数值存储到p所指向的数组元素

[ 如果p所指向的数组元素数值为0，则代码跳转到到]后面的指令执行；否则执行[后面的指令。
] 如果p所指向的数组元素数值为0，则代码跳转到到]后面的指令执行；否则执行[后面的指令。

注意：
brainfuck语言采用的是代码和数据分离存储的架构。代码的执行可以修改数据，当前位置p指向的数值也会影响指令[和]的执行路径。
前6条指令都是指令影响数据，后面2条指令是数据影响指令。
 
使用BF语言输出字母'H'怎么实现呢？BF代码如下：

++++++++[>+++++++++<-]>.

首先在p[0]位置设置数值8，然后判断p[0]是否等于0，此时p[0]==8，不等于0则指针p向后移动1个位置，p指向数组的1位置。
接着在p[1]位置设置数值9，然后指针p向前移动1个位置，p指向数组的0位置，并且将p[0]的数值减去1。
接着判断p[0]是否等于0，此时p[0]==7，不等于0则指针p回到[的后面一条指令继续执行。重复上面的步骤直到p[0]的数值等于0。
p[0]等于0后，则执行]后面的指令>，即指针p向后移动1个位置，p指向数组的1位置，并且输出p[1]的数值。

可以看到，上面的BF代码，使用了数组的2个位置（即两个变量）p[0]和p[1]，p[0]是作为判断条件使用的，p[1]是作为数值计算使用的，最后输出的是p[1]的数值。

p[1]最终的数值是8*9=72，即'H'的ascii数值。p[0]最终的数值是0，才能跳出循环到输出指令执行。

我们能不能将BF的代码也存储到默认数组中呢？答案是可以的（冯诺依曼结构）。不过需要额外的执行控制机构来控制代码的执行。

[下载](documents/TestBF.zip)

