# C语言内存管理函数

>*作者：Arvin 日期：2017年7月5日*

-----------------------------------

>BEGIN

内存管理函数分：内存分配、内存重新分配和内存释放。函数声明位于C标准库<stdlib.h>头文件中。主要分配和释放进程中堆的内存（BSS段）。全部需要通过操作系统的系统调用来实现。概念上类似，从系统申请内存和归还内存给系统。

    void* malloc(size_t size);
    void* calloc(size_t nitems, size_t size);
    void* realloc(void* ptr, size_t size);
    void  free(void* ptr);

`malloc`函数按输入的大小`size`分配堆内存，单位是字节，成功返回所分配内存的首指针，失败返回NULL。`calloc`函数功能同`malloc`函数，区别在于输入的参数不同，`calloc`函数按照大小为`size`字节的`nitems`个内存块的方式来分配内存，按照内存块分配，返回跟`malloc`函数一样。`realloc`函数是对已有的内存重新调整大小，可增加大小也可以减小大小。减小可能会丢失部分原有数据。输入参数`ptr`为NULL时则分配一块新内存并返回内存首指针，如果输入参数`size`为0，则释放`ptr`所指向的内存块，并返回NULL。`realloc`函数成功返回所分配内存的首指针，失败返回NULL。`realloc`如果调用成功，则返回的指针跟参数`ptr`一样。`free`函数释放指针`ptr`所指向的内存。如果输入参数`prt`为NULL，则不执行任何操作直接返回。

任何范围都有边界，任何事物都有局限性。`size_t`是一个与机器相关的unsigned整数类型，不同机器可能是不同的类型，并且是无符号整数类型。函数返回和函数输入`ptr`是`void*`指针类型。就像黑和白是光的两面一样，由于存在边界（适用范围）上面4个函数的输入也存在正反两面。函数的输出可以由函数内部控制，但是函数的输入则是完全由人来控制的。输入的正面代表“类型正确”和“大小适中”的数据输入；输入的反面是“类型错误”和“大小溢出”。由于`size_t`可以表示特定机器足够大的无符号整数，正常情况下基本不会出问题，除非你输入的数字超过机器能表示的最大无符号整数或小于机器最小的无符号整数。另外一种情况是参数`size`的输入符合`size_t`类型和大小，但是函数内部却没有正确的处理这个输入（类型或大小），举例来讲，内部做了隐式的类型转换导致数据异常或者丢失数据等；大小没有做正常的限制导致分配的内存区域小于或者超出所期望的区域（缓冲区溢出）。参数`ptr`是`void*`类型，取值范围是NULL、正常的指针和人造非正常的指针。由于指针可以人为伪造，参数`ptr`的情况更加复杂，可控性更差，可造成更多的安全隐患。作为hacker更多的是设计符合函数声明但是函数内部没有正确处理的输入；作为programmer更多的是限制输入边界、正确处理边界内的输入以及函数返回值作为另一个函数的参数输入；作为学习者需要同时考虑正常和非正常输入函数的返回结果。这就是程序的正反两面。

比如上面的`malloc`函数，"错误类型"的输入-1、0和1.9等会返回什么呢？"错误大小"的输入ULONG_MAX等会返回什么呢？

下面是"相对安全"的内存管理函数：

    void* xmalloc(size_t size)
    {
        void* data = malloc(size);
        if(!data){
            fprintf(stderr, "failed to allocate memory\n");
            exit(EXIT_FAILURE);
        }
        return data;
    }

    void* xrealloc(void* ptr, size_t size)
    {
        void *data = realloc(ptr, size);
        if (!data){
            fprintf(stderr, "failed to allocate memory\n");
            exit(EXIT_FAILURE);
        }
        return data;
    }

    void xfree(void* ptr)
    {
        if(ptr){
            free(ptr);
        }
    }

上面的函数会尽早的检查输入和返回，给出提示并终止程序执行。

自己可以按照上面的思路，测试一下C标准库内存管理函数在非正常输入情况下的返回值。进一步可以找一下函数的实现源码，分析一下函数内部处理正常和非正常输入的处理逻辑。找找看看有没有漏洞以及总结一下写代码的一些有用规则。

>END
