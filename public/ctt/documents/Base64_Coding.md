
# Base64编解码

> *作者：Arvin 日期：2018年11月24日*

---------------------------------

>BEGIN

Base64编码是将任意二进制数据转换成可见的有限的ascii字符串。这种做法其实挺傻的，但是实际开发中还是会用到的。

### 一、原理分析
---------------------------------

```3*8 = 4*6``` 这就是Base64编码的根本原理。3个字节可以用4个ascii字符进行表示。

为什么是ascii字符呢？ascii码每个字符占用1字节，并且只用到1个字节的低7位，对于只需要1个字节低6位的Base64编码足够。只需要6位，那么1字节中剩余的2位怎么办？置零，也就是空闲。这也是为什么经过Base64编码的数据比原数据大的原因。

举例：

```
0x3F45A3用Base64编码是什么？

0x3F45A3 == 00111111 01000101 10100011 == 001111 110100 010110 100011

高2位补零得到：00001111 00110100 00010110 00100011 == 0x0F 0x34 0x16 0x23

换算到Base64编码得到：PyWj

```

首先```0x0F```的ascii并不是字符```P```为什么Base64的编码是字符```P```？原因是ascii中并不是所有字符都是可见的。字符```0x0F```就不是可见字符，它在ascii码中是控制字符SI。
为了方便阅读（设计Base64编码的前辈可能是这样想的吧:）？Base64编码使用的ascii字符都是可见的，如下：

```
static unsigned char base64EncodeLookup[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

```

共64个可见字符，数组最后一个字符是C的字符串结束符号```\0```，不参与编码。为什么是64个字符？Base64编码只用1字节的低6位，也就是```2^6```即64个。
上面的数组本质上是一个映射表，将Base64编码的数值作为数组的下标映射出对应的ascii字符。这里顺便说一下解码的映射表：

```
#define xx 65

static unsigned char base64DecodeLookup[256] =
{
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx,
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx,
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, 62, xx, xx, xx, 63,
	52, 53, 54, 55, 56, 57, 58, 59, 60, 61, xx, xx, xx, xx, xx, xx,
	xx,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
	15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, xx, xx, xx, xx, xx,
	xx, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
	41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, xx, xx, xx, xx, xx,
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx,
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx,
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx,
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx,
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx,
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx,
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx,
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx,
};

```

解码是ascii字符的值作为数组下标映射到二进制1个字节的低6位的过程。由于ascii字符占用1字节，也就是最多256个（可能）。

上面的```xx```是65，超出了0-64的范围，是无效值。

Base64在编码的过程又一个问题是：Base64是将3个字节转换成4个字节的过程，并不是所有二进制数据的字节数都是3的倍数，也就是最后可能存在剩余1个或者2个字节的可能，这剩余的字节怎么处理？

简单粗暴，剩余的部分用```=```补齐。可以理解成剩余1字节，那么我们补齐剩下的2字节0，正常转换后，将无用的字符0用字符```=```代替。

如果剩余1字节，需要2个字节转换（有效字节）剩余的2字节用```=```补齐；如果剩余2字节，需要3字节转换（有效字节）剩余的1字节用```=```补齐。

字符```=```的数值是61，解码得到的是```xx```也就是无效的65。补齐的字符映射后必须是超出0-64数值范围的。

这就是所有的Base64原理知识。（注意：Base64不是加密方法，它是一种二进制编码方法）


### 二、随便说点
---------------------------------

1. 原理很简单，衍生的细节和问题也需要考虑全面，设计使用的元素尽量对人友好；
2. 因为涉及到对二进制操作，Base64编解码程序一般使用C来实现，而且基本都使用数组作为映射表（注意这种程序设计方法）；
3. Base64编解码不需要另外的存储数据，而且具有通用性，它适合作为工具来使用，一般作为类方法暴露（封装）给其他方法使用；
4. 你可以用通过Base64编码来用字符串表示任何计算机数据，比如：exe、图片、视频、文本等；
5. 个人还是喜欢二进制格式的数据，简洁通用占用空间小；相对于obj格式的3D模型，个人更加喜欢ms3d格式；

>END

[代码下载](documents/Base64.zip)

