
# Doom风格的软渲染器

> *作者：Arvin 日期：2018年02月27日*

---------------------------------

>BEGIN

春节经历不少事情，爷爷的过世（2月13日），感冒，撕心裂肺的急性扁桃体发炎。。。到现在一切总算过去了，静下心来写春节过后的第一篇文章。一直想写关于软渲染方面的文章，自己也写过简单的软渲染器，基于三角形的软渲染，比较通用但是由于性能问题不怎么实用，类似Demo吧。去年偶尔在Youtube上看到大神写了个Doom风格的渲染器，研究了一下代码，感觉有一定的实用性，并且非常简单，易于理解。所以这篇主要还是基于大神的那个渲染器进行分析和讲解。（基于三角形的软渲染，有机会再说吧）。

### 一、思路
---------------------------------

渲染的本质是将计算好的颜色值写入对应的像素点。如何计算颜色值是渲染的关键。像素点的颜色值计算涉及到光照、纹理、材质等。我们这里为了简化，假定物体本身会发出固定的光线（物体本身有颜色值）。我们只关注如何计算和填充像素点。视频是由一帧一帧的图片连续播放形成的，我们要讲的是实时渲染器，也就是通过渲染器我们能产生视频。（视频游戏都是实时渲染的）

### 二、几个宏的定义
---------------------------------

```
#define min(a,b) (((a) < (b)) ? (a) : (b))
```
返回两个数值的较小者。注意每个数值都使用小括号括起来，具有更好的通用性，以免在使用该宏的时候产生歧义。还有一个特点是a和b必须是数值（可以使用关系运算），但对数值的类型没什么要求，可以是整数，也可以是实数。

```
#define max(a,b) (((a) > (b)) ? (a) : (b))
```
返回两个数值的较大者。

```
#define clamp(a, mi,ma) min(max(a,mi),ma)
```
返回在mi和ma之间的a数值。如果a小于mi，则返回mi；如果a大于ma，则返回ma；如果a在mi和ma之间，则返回a本身。

```
#define Overlap(a0,a1,b0,b1) (min(a0,a1) <= max(b0,b1) && min(b0,b1) <= max(a0,a1))
```
判断范围[a0,a1]跟范围[b0,b1]是否存在重叠部分。关键判断是后面的关系表达式。

```
#define IntersectBox(x0,y0, x1,y1, x2,y2, x3,y3) (Overlap(x0,x1,x2,x3) && Overlap(y0,y1,y2,y3))
```
判断两个2D盒子（矩形）是否存在重叠部分。注意(x0,y0)和(x1,y1)是第一个盒子的对角线两点的坐标。

```
#define vxs(x0,y0, x1,y1) ((x0)*(y1) - (x1)*(y0))
```
返回向量(x0,y0)与向量(x1,y1)的外积在Z轴的数值。根据向量的运算公式得到。

```
#define PointSide(px,py, x0,y0, x1,y1) vxs((x1)-(x0), (y1)-(y0), (px)-(x0), (py)-(y0))
```
判断点(px,py)在线段(x0,y0)--(x1,y1)的上面或者下面。返回值：<0 点在直线下面, =0 点在直线上, >0 点在直线上面。向量外积Z轴分量数值的正负表示向量的旋转方向（右手法则）。仔细理解一下，有点难。

```
#define Intersect(x1,y1, x2,y2, x3,y3, x4,y4) ((struct xy) { \
vxs(vxs(x1,y1, x2,y2), (x1)-(x2), vxs(x3,y3, x4,y4), (x3)-(x4)) / vxs((x1)-(x2), (y1)-(y2), (x3)-(x4), (y3)-(y4)), \
vxs(vxs(x1,y1, x2,y2), (y1)-(y2), vxs(x3,y3, x4,y4), (y3)-(y4)) / vxs((x1)-(x2), (y1)-(y2), (x3)-(x4), (y3)-(y4)) })
```
返回两条直线的交点坐标。分别计算交点的x和y即可。公式自己展开分析。比较复杂。

### 三、两个实体的定义
---------------------------------

两个实体分别是房间和玩家。房间我们用多边形区域来表示，玩家需要记录空间坐标和所在多边形区域，以及head的旋转角度等。

```
static struct sector
{
    float floor, ceil;
    struct xy { float x,y; } *vertex;
    signed char *neighbors;
    unsigned npoints;
} *sectors = NULL;
static unsigned NumSectors = 0;
```

```
static struct player
{
    struct xyz { float x,y,z; } where, velocity;
    float angle, anglesin, anglecos, yaw;
    unsigned sector;
} player;
```

### 六、随便说点
---------------------------------

1. 优化的方向是“最小内存，最少指令周期”；
2. 通过增加新维度的限制，来增加新的功能；


>END

[代码下载](documents/OBShapedButton.zip)

