
# 一行C代码

> *作者：Arvin 日期：2019年7月24日*

---------------------------------

>BEGIN

2018年的[IOCCC](https://www.ioccc.org/years.html)大赛结果出来了，看到一个一行代码的作品。写的比较巧妙，就来分析分析。

### 一、源码和作用
---------------------------------

下面是这段C语言代码：

```

char O,o[];main(l){for(;~l;O||puts(o))O=(O[o]=~(l=getchar())?4<(4^l>>5)?l:46:0)?-~O&printf("%02x ",l)*5:!O;}

```

如果你用过vim的二进制编辑模式，或者其他的二进制编辑工具，你就对这段代码的作用感到熟悉。它的作用是在左边打印16进制，在右边输出ascii字符。如下所示：

```

Last login: Wed Jul 24 09:38:25 on console
dikadeiMac:~ dika$ cd Desktop/
dikadeiMac:Desktop dika$ ./hello123 < h.c
63 68 61 72 20 4f 2c 6f 5b 5d 3b 6d 61 69 6e 28 char O,o[];main(
6c 29 7b 66 6f 72 28 3b 7e 6c 3b 4f 7c 7c 70 75 l){for(;~l;O||pu
74 73 28 6f 29 29 4f 3d 28 4f 5b 6f 5d 3d 7e 28 ts(o))O=(O[o]=~(
6c 3d 67 65 74 63 68 61 72 28 29 29 3f 34 3c 28 l=getchar())?4<(
34 5e 6c 3e 3e 35 29 3f 6c 3a 34 36 3a 30 29 3f 4^l>>5)?l:46:0)?
2d 7e 4f 26 70 72 69 6e 74 66 28 22 25 30 32 78 -~O&printf("%02x
20 22 2c 6c 29 2a 35 3a 21 4f 3b 7d 0a  ",l)*5:!O;}.
dikadeiMac:Desktop dika$ 

```


### 二、代码做了什么？
---------------------------------

为了方便分析首先将这一句话拆分成下面的等效形式。

```
#include <stdio.h>

char O = 0, o[17] = {0};

int main(int l, char** argv)
{
    for(; ~l ; O||puts(o))
    {
        if (~(l = getchar()))
        {
            O[o] = 4<(4^(l>>5)) ? l : 46;//从可见字符开始
        }
        else
        {
            O[o] = 0;
        }
        //
        if (O[o])
        {
            O = (-~O)&(printf("%02x ",l)*5);//0-15循环
        }
        else
        {
            O = !O;
        }
    }
}

```

这段代码虽然比较简短但并不简单。里面使用了几个C语言的技巧。

```

for(; ~l ; O||puts(o))
{
    //.....
}

/*
~l，这里的l是从管道获取的单个字符（第一次是命令行参数个数1），~是按位取反运算，对于l来讲只有等于0的时候（也就是字符串结束符）为假。所欲ascii字符只有'\0'能是~l为假。即，当l读取到的是字符串结束符的时候才会退出for循环。

O||puts(o)，小o是字符数组（可以认为是一个可包含16个字符的字符串，最后一位是字符串结束符），puts函数是输出字符串并且将结束符换成回车符输出。大O是char整型，可以为0。这个表达式用了C语言的一个技巧，||运算符，从左到右进行运算求值，如果左边有任何一个表达式为真则整个表达式为真并且后面的表达式不会去求值（不会执行求值操作）。也就是当大O为假的时候才会执行puts函数，即输出小o代表的字符串。

*/

```

```

char O = 0, o[17] = {0};

O[o] = 4<(4^(l>>5)) ? l : 46;//从可见字符开始

/*
O[o]，这里不是正常的数组下标运算符使用方法。这里的小o是字符数组的开始地址，可以认为是一个数组指针变量。大O是一个char的整型变量。O[o] 等价于 o[O]。O[o] = *(O + o)。

4<(4^(l>>5))，判断是否是可见字符。高三位为0的ascii字符都是不可见字符。46为字符'.'，也就是不可见字符用它来占位。

*/

```

```

O = (-~O)&(printf("%02x ",l)*5);//0-15循环

/*
printf("%02x ",l)，该函数的返回值永远是3。printf函数返回的是显示在屏幕上的字符数，并不是内存中要输出的字符个数。如：打印字符A的ascii值为65，返回值为2（65显示起来占用2个字符）。

(-~O)，它的值是O+1。正整数自增1的另外一种实现。利用了补码的原理。0001的按位取反为1110，然后进行取负指运算为（负数）除符号位都取反然后加上1最后修改符号位位0，也就是0001->1110->1001->1010->0010，也就是最后得到2。这种操作对正整数是通用的（其他类型的自己可以去尝试）。本质是利用了求负数的补码自动加上1的特点。

&15，即取某个数值的低4位。也就是限定了整个表达式的取值范围为：0-15。

*/

```

上面6个C语言编程技巧，可以帮助理解代码。整个的逻辑如下：

1》从管道读取一个字符l，如果它为可见字符则保存在字符数组o中，如果为不可见字符则用字符'.'代替保存在数组o中，如果为结束符则输出数组o并退出程序；
2》如果当前读取的字符不为结束符则输出该字符的2位ascii的16进制值。
3》如果大O为0则输出字符数组o。

### 三、随便说点
---------------------------------

上面6个技巧，平常一般是看不到的。有点巧妙（聪明），不过也在情理之中（并没有违背C的语义）。不提倡在正常开发中使用，但也可以加深对C语言的理解。

>END