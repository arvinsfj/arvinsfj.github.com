
# RGB像素格式

> *作者：Arvin 日期：2017年5月31日*

---------------------------------

>BEGIN

### RGB简介
------------------------------

RGB色彩模式是工业界的一种颜色标准，是通过对红(R)、绿(G)、蓝(B)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。

R：red G：green B：blue A：alpha

原理：颜色发光，颜色叠加。

取值范围：当每个分支用1个字节表示时，各个颜色分之都是0-255，代表着各分支的亮度，加法混合。

每个像素（Pixel）由3个或4个分支构成，RGB或RGBA或ARGB。

颜色种数：当每个分支用1个字节表示时，256x256x256种，alpha值表示透明度（背景混合）。

灰度：即黑白程度，也叫灰阶值，代表明亮程度，不包含色彩信息。

灰度 = (R+G+B)/3

灰度可以有两种表示，1）单位面积下的亮度，2）单位面积下黑色所占比例。

### RGB应用
-----------------------------------

操作：我们可以认为是对对象（数据）的增、删、改、查、排序操作。

知道了每个像素的构成原理，我们能做的事情太多了。比如：绘制点、绘制线、绘制三角形、绘制矩形、绘制面、绘制文字、绘制3D模型、ppu等。显示器下所有可视物体都可以通过操作像素来得到。而物体的事件都是通过hittest来响应，这里不对事件进行分析。

在绘制这些元素之前，我们需要一个编程平台，bitmap、dx、opengl、sdl2等都行，只要能将像素集合显示出来就可以。单个像素表现为一点，能表示的信息比较少，只能表示颜色。像素的有序集合能表示线和面。显示器是二维的面，我们的像素操作大部分都是在二维进行的。通过像素的二维排列和像素的颜色（位置和颜色）我们可以构成图形、文字，彩色图片。通过对图片的时序排列，我们可以构成动画和视频。当然声音是视频的另外一个方面，我们暂不考虑。

二维像素操作比较简单，归根结底就是操作数组中的RGBA。三维像素操作就比较复杂，涉及到三维空间变换和一些算法，操作在三维空间显示在二维平面，但是已经有很多前辈的研究总结，和成熟规范的公式。根据我的经验，涉及算法的像素操作，基本都是高维显示，大致就是像素块操作和3维像素点操作，比如：PPU的CHR操作、文字字模操作、3D模型光栅化操作等等。

我们受外界影响可以通过操作像素数组来生成文字、图片、动画、视频等来保存有用信息；反过来，我们能不能通过文字字模、图片、视频中的像素信息来提取识别外界信息？对于人来讲，很简单，就是图像识别，但是对于计算机则是一门学科，机器学习中的图像识别，涉及到计算机的AI，是信息的转换过程。比如：手写体识别，就是墨迹图片到字符机器码（ASCII码）的转换过程，信息丛一种存储格式转换成另一种存储格式，这其中涉及信息的部分丢失，我不确定机器本身有没有“0”的概念，能不能使用“0”的概念进行分析、运算和推理。人的智能大部分是基于概念的运算和推理，以及形象思维的识别、分析和综合。

### RGB举例
-----------------------------------

1. 绘制点：可以用4个字节分别表示像素的RGBA，然后写入显示系统，可以是一张图片。也可以使用2个字节来表示RGBA，即每个分支占用4位。由于涉及到字节和位的操作，建议使用C语言进行编程。由于RGBA的表示不同，根据具体情况可能需要格式转换。

2. 绘制线：将绘制点功能封装成函数，自变量x取一个连续的范围，通过直线方程获取因变量y的值，形成位置点（x,y），将像素的RGBA设置成固定的值（最好带颜色），最后将像素值写进位置点（x,y）即可得到一条线段(数值微分算法DDA)。根据计算机的显示特点和性能要求，可以改进该算法，针对具体平台进行改进。如：Bresenham算法、对称直线生成算法以及两步算法等。

3. 绘制三角形：讲的是绘制三角形所在区域，其实是绘制面。面的绘制建立在绘制线的基础之上，所谓“线动成面”。为了寻求通用的绘制三角形的算法，首先需要对三角形进行分类。三角形一般分成三类：平底上三角形、平头下三角形、平底平头组合三角形。平底三角形绘制，整体可以从上到下（Y轴）获取yx，并计算两边对应的x0和x1，然后绘制（x0,yx）到（x1,yx）的线段，注意这里线段的y值相等。这里给出了位置的计算方式，对于各个像素点的RGBA数值，则可以通过三个顶点颜色在Y轴和X轴的插值来计算。通过Y轴插值可以计算（x0,yx）和（x1,yx）两点的颜色，通过X轴插值可以计算（x0,yx）到（x1,yx）线段任意像素点的颜色。在实际三角形绘制中还涉及到光线、材质和贴图等。平头三角形类似平底三角形绘制，组合三角形就是切割成平底和平头三角形然后分开绘制。三角形绘制一般用于3D模型的绘制。

4. 矩形绘制：可以切割成2个三角形进行绘制，也可以直接绘制。根据矩形的特点，对面的两条边长度相等，可以通过Y轴的插值获取两点（x0,yx）和（x1,yx），然后绘制（x0,yx）到（x1,yx）的线段。像素颜色的计算按照插值方式进行。矩形绘制可以用于3D房间和场景构建。

5. 绘制面：一般切割成三角形或矩形进行绘制。

6. 绘制文字：即显示文字，通过字符的机器码表示，比如：'A'即65，获取字符的图片表示，即字符的字模，然后将字符图片写入显示系统。字体分为等宽和可变宽，这里只考虑等宽字体，而且只考虑英文的可见字符（32-126）。可以根据该原理写一个简单的英文文本阅读器。首先找一个ascii码等宽字模文件，一般字符都是一个接一个连续排列的，并且每个字符的像素点也是连续排列的。其次，将字符机器码（即ASCii值）作为索引值，配合等宽字体的单个字体所占用的字节数，来计算字符在字模中的指针（位置），读取整个字符的字模像素集合并写入显示系统。可变宽字体，需要动态计算字模的宽度。你可以想象字模文件就是所有字符图片顺序排列成的一张大图片，并且你完全可以将字模文件可见区域做成一张图片。这种做法不仅仅用于文字显示，也用于游戏中的精灵，比如：NES中的CHR表格和精灵的帧动画。

7. 绘制3D模型：基于三角形的绘制，兼顾3D顶点变换和颜色插值。顶点变换意味着三角形顶点的变化即不同的三角形，不同的角度看到的同一个三角形的形状是不一样的。但是我们有通用的三角形绘制算法，也就不必考虑这个因素。3D模型绘制重点还是顶点的3D变换和颜色插值。顶点变换，通过仿射矩阵（平移、缩放、旋转）来计算，其他还有透视矩阵和视窗变换。颜色插值，主要是光线、材质、纹理，现代的3D组件，比如：opengl、dx等都提供顶点着色器和片段着色器。着色算法有：flat算法、phong算法、gouraud算法等，运算量依次增大。材质是物体的光学特性，反射多少、吸收多少、漫反射、镜面反射等等。光线是直接影响物体的光线特征。纹理是物体的表面特征。物体的颜色也是从顶点开始的，主要是顶点法向量。其他3D的方面，主要是场景构建、骨骼动画、地形系统、粒子系统等。3D模型绘制，还有一种光栅化方法是光线追踪算法体系，主要用于离线渲染，运算量巨大，但效果非常逼真。基于三角形的3D光栅化算法体系一般用于即时渲染，比如：3D游戏。

8. PPU：任天堂系列游戏机（NES等）中使用的图形芯片，一般出现在NES模拟器开发中。可以认为是现代显卡的雏型。作用类似于文字显示，将CHR的像素块写入显示系统，但是其受控于CPU（6502）。主要分为背景的绘制和精灵的绘制。背景基于网格，精灵没有这个限制。色彩基于系统内置的64种固定颜色（其实小于64种）。有兴趣的可以在[NESDev](http://wiki.nesdev.com)网站查看具体的实现，也可以参考博客[NES Graphics](http://www.dustmop.io/blog/2015/04/28/nes-graphics-part-1/)。

9. 字符画：即用特定几个字符来替代图片像素所形成的图片。最终图片是灰度图片（黑白图片），因为字符一般就是黑色和白色的。原理很简单，首先计算图片的灰度（灰度=(R+G+B)/3），其次选取“灰度”字符"  ","#","$","=","*","!",";",":","~","-",",","."," "," " 并且确保使用等宽字体（否则画面会变形，字符宽度不一致造成的），最后，读取原始图片的灰度值并且映射到灰度字符，通过文本显示组件显示字符即可得到字符画。这里面灰度字符的选取是关键，前面讲过，灰度可以使用"单位面积下黑色所占比例"来表示。上面的字符仔细观察，可以发现在等宽字体的前提下，字符有效区域（黑色部分）是依次减小的。最大是字符'#'，最小是字符空格' '。组合起来就是有些区域时白色的，有些区域是松散黑色（中等灰度），有些区域时密集黑色（灰度比较大）。

10. 地形系统：地形系统是3D场景的一个方面，原理就是在二维平面相应的顶点上加上高度值，形成（x,y,z）的3D顶点。一般高度值存储在一张灰度图里面（高度图），亮度越大的地方高度值越大，越暗的地方高度越低，当然可以位负数值，表示凹下去的地形。二维平面可以使用三角形集合表示，只是缺少Z轴数值。通过修改高度图可以创建不同的地形。同时，高度图里面还可以存放法向量、纹理坐标等信息，来确定地形的光照和纹理。

>END

