
# 操作系统：xv6

> *作者：Arvin 日期：2018年6月29日*

---------------------------------

>BEGIN

### 一、xv6是什么?
---------------------------------

xv6是一款简单的、类unix的教学用操作系统。

### 二、这篇文章的目的
---------------------------------

这篇文章是为操作系统课程教学准备的。它通过学习一个内核例子（称作'xv6'）解释了操作系统的主要概念。xv6是DR和KT第6版Unix（v6）的重新实现。xv6遵循v6的结构和风格，但基于x86的多核处理器使用标准C实现。

该篇文章需要结合xv6的源代码进行阅读。我们已经在6.828课程（MIT的操作系统课程）中使用了该篇文章。

### 三、细读和分析
---------------------------------

1. 操作系统接口（界面）

操作系统的工作是在多个程序之间共享计算机（硬件）和提供比单独（计算机）硬件更加有用处的服务集。操作系统管理和抽象底层硬件，如此一来，例如，字处理（软件）自己就不必关心用的是什么类型的磁盘。它（操作系统）也复用硬件，允许许多程序共享计算机（硬件）和同时运行（或者准备运行）。最后，操作系统提供了一个可控制的程序交互方法，这样它们之间就能共享数据或者共同工作了。

操作系统通过接口向用户程序提供服务。设计一个好的接口被证明是困难的。一方面，我们希望这个接口简单和（功能）狭窄，因为这样让它更加简单的能被正确实现；另一方面，我们被怂恿去提供许多复杂的应用特征。解决这种紧张的诀窍是去设计依赖少数机制（能通过组合提供很多通用性的机制）的接口。

这本书使用单一的操作系统作为一个具体的例子来说明操作系统的概念。那个操作系统（xv6）提供基本的接口（KT和DR的Unix操作系统中介绍的）和类似Unix的内部设计。Unix提供一个（功能）狭窄的接口，它的机制组合的很好，提供了令人惊讶的通用性。这个接口是如此的成功，以至于现代操作系统（BSD、Linux、OSX、Solaris和Windows）拥有类Unix的接口。理解xv6是理解这些和其他的操作系统的一个好开始。

xv6采用传统的内核（一段特别的程序，它为正在运行的程序提供服务）形式。每一个正在运行的程序，被称作一个进程，拥有一段包含指令、数据和一个栈的内存。指令实现程序的计算；数据是用于计算的变量；栈组织程序的过程调用。

当一个进程需要使用一个内核服务，它用操作系统接口实现一个过程调用。这样的一个过程被称作一个系统调用。系统调用陷入内核，内核实现服务和返回结果。因此，一个进程会在内核空间和用户空间交替执行。

内核使用CPU的硬件保护机制来确保每个在用户空间执行的进程只能访问它自己的内存。内核在拥有实现这些保护机制的硬件特权下运行。用户程序不在那些硬件特权下运行。当一个用户程序行使一个系统调用，硬件会提升特权级别和开始运行一个在内核中事先写好的功能。

内核提供的系统调用集合是用户程序可见的接口。xv6内核提供的是Unix内核传统服务和系统调用的子集。

```
fork()                    Create process
exit()                    Terminate current process
wait()                    Wait for a child process to exit
kill(pid)                 Terminate process pid
getpid()                  Return current process’s id
sleep(n)                  Sleep for n seconds
exec(filename, *argv)     Load a file and execute it
sbrk(n)                   Grow process’s memory by n bytes
open(filename, flags)     Open a file; flags indicate read/write
read(fd, buf, n)          Read n byes from an open file into buf
write(fd, buf, n)         Write n bytes to an open file
close(fd)                 Release open file fd
dup(fd)                   Duplicate fd
pipe(p)                   Create a pipe and return fd’s in p
chdir(dirname)            Change the current directory
mkdir(dirname)            Create a new directory
mknod(name, major, minor)      Create a device file
fstat(fd)                 Return info about an open file
link(f1, f2)              Create another name (f2) for the file f1
unlink(filename)          Remove a file

```

本节剩下的内容概括了xv6的服务（进程、内存、文件描述符、管道和文件系统）和通过代码片段和shell如何使用它们的讨论来说明它们。shell对系统调用的使用说明它们（服务或着接口）是多么小心的被设计的。

shell是普通的程序，它读取用户的命令和运行命令，对于传统的类Unix系统来讲它是主要的用户界面。shell是用户程序的事实，不是内核的一部分，说明了系统调用接口的强大力量：shell没什么特别的。它同时意味着shell可以很容易被替换。作为一个结果，现代Unix系统有很多可以选择的shell，每一个shell有它自己的用户界面和脚本特点。xv6的shell是对Unix Bourne shell的精髓部分的一个简单实现。

-------------------------

进程和内存

xv6进程是由用户空间的内存（指令、数据和栈）和每个进程的内核私有状态组成的。xv6能进行分时共享处理：它在等待运行的进程集合中透明的切换可用的CPU。当一个进程不在运行时，xv6保存它的CPU寄存器，当进程下一次运行时重新恢复它们（寄存器的值）。内核关联一个进程唯一标识，或者称作pid，到每个进程。

一个进程可能通过fork系统调用创建一个新进程。Fork创建一个新进程，被称作子进程，它拥有跟调用进程完全一样的内存内容，调用进程被称作父进程。Fork在父进程和子进程都会返回。在父进程中，fork返回子进程的pid，在子进程中，它（fork）返回0。

```
int pid = fork();
     if(pid > 0){
       printf("parent: child=%d\n", pid);
       pid = wait();
       printf("child %d is done\n", pid);
     } else if(pid == 0){
       printf("child: exiting\n");
       exit();
     } else {
       printf("fork error\n");
}

```

exit系统调用会导致调用进程停止运行，并且释放像内存和打开的文件这样的资源。wait系统调用返回一个当前进程已经停止了的子进程的pid。如果没有调用者的子进程停止，wait会等待直到一个子进程停止。

注意，父进程和子进程运行在不同的内存中和不同的寄存器值：改变一个进程的变量不影响另一个进程。

exec系统调用将调用进程的内存替换成一个从文件（文件系统中的）加载的新内存镜像。这个文件必须拥有特定的格式，格式说明了文件的哪部分包含了指令，哪部分是数据，从哪条指令开始运行等。xv6使用ELF格式，在第二节作更加详细的讨论。当exec成功执行，它不会返回调用程序；相反的，它从文件加载的在ELF头中被定义成入口的指令开始执行。Exec需要两个参数：可执行文件的名字和字符串数组。

```
char *argv[3];
argv[0] = "echo";     
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");

```

上面的代码片段替换调用程序成一个程序（/bin/echo）实例，它有实参列表echo hello。大多数程序忽略第一个参数，按照惯例它是程序的名称。

xv6的shell使用上面的调用来运行用户程序。shell的主体结构是简单的。请看main函数。主循环使用getcmd函数从命令行读取用户输入，然后它调用fork系统调用（它创建一个shell进程的拷贝）。当子进程运行命令的时候，父shell调用wall函数（等待子进程结束）。举例，如果用户在prompt输入“echo hello”，runcmd函数将被调用，并且带有“echo hello”参数。runcmd运行实际的命令。对于“echo hello”，它将调用exec函数。如果exec成功，子进程将运行echo的指令来替代runcmd。在某个时刻echo将会调用exit，它将会引起在父进程从wait返回在main中。你也许会疑问，为什么fork和exec不封装成一个系统调用。我们将在后面看到，将创建进程和加载程序分成两个系统调用是聪明的设计。

xv6隐式的分配大多数用户空间内存。fork分配必须的内存以满足子进程对父进程的拷贝，exec分配足够的内存来装载可执行文件。进程在运行的时候需要更多的内存（也许为了malloc）可以调用sbrk(n)函数来增加n子节的数据内存。sbrk返回新内存的位置（地址）。

xv6不提供用户或者用户保护的概念。在Unix概念里，所有的xv6进程都是root运行。

---------------------------

I/O和文件描述符

一个文件描述符是一个小的整数，代表着内核管理的进程可读写的对象。进程也许通过打开一个文件、文件夹或设备，或者通过创建一个管道，或者通过复制一个已存在的描述符来获取一个文件描述符。为了简单起见，我们经常将对象（文件描述符）描述成“文件”。文件描述符接口的抽象使我们远离文件、管道和设备的不同，使它们看起来都是字节流。

内部的，xv6内核使用文件描述符作为每个进程表的索引（index），这样每个进程拥有从0开始的文件描述符私有空间。为了方便，进程从描述符0（标准输入）读取数据，写入数据到描述符1（标准输出），写入错误信息到文件描述符2（标准错误）。我们将看到，shell利用这种便利性来实现I/O的重定向和管道。shell保证它经常拥有3个打开的文件描述符，它们是console的默认文件描述符。

read和write系统调用从打开的文件（称作文件描述符）读取子节和写子节到打开的文件。调用read(fd,buf,n)从文件描述符fd中读取最多n子节数据，将它们复制到buf中，然后返回实际读取的子节数量。每一个关联到文件的文件描述符拥有一个关联的偏移量。Read从当前的文件偏移量（位置）读取数据，然后将偏移量前移实际读取的子节数量：后面的读取的子节是紧跟第一次读取的子节。当没有更多的子节需要读取的时候，read返回0来表示文件的结束。

调用write(fd,buf,n)从buf中写入n子节数据到文件描述符fd。并且返回被写入的子节数量。仅当错误的发生，少于n子节被写入。类似read，write从当前文件偏移量位置写入数据，并且前移被写入子节数量的偏移量：每次写采用前一次写剩下的。

下面的程序片段（cat的精髓部分）从标准输入拷贝数据到标准输出，如果有错误，它写一个错误信息到标准错误。

```
char buf[512];
int n;
for(;;){
    n = read(0, buf, sizeof buf);
    if(n == 0) break;
    if(n < 0){
        fprintf(2, "read error\n");
        exit(); 
    }
    if(write(1, buf, n) != n){
        fprintf(2, "write error\n");
        exit();
    } 
}

```

代码片段中需要重点注意的事情是cat并不知道它是从一个文件、console或者一个管道读数据的。类似的，cat并不知道它打印的地方是console、一个文件或者任意什么东西。文件描述符的使用和描述符0是输入、描述符1是输出的便利性允许cat的简单实现。

close系统调用释放一个文件描述符，让它释放以便将来在open、pip或者dup系统调用中重用。新分配的文件描述符总是当前进程中没有被使用的描述符中最小的数字。

文件描述符和fork结合让I/O重定向实现起来很简单。Fork跟着拷贝内存一起拷贝父进程的文件描述符表，这样子进程拥有父进程一样的打开的文件。系统调用exec替换调用进程的内存但是保留它的文件表。这种行为允许shell通过fork实现I/O重定向，重新打开被选择的文件描述符，然后运行新的程序。这里有一个简单版本的运行命令“cat < input.txt”的shell代码。

```
char *argv[2];
argv[0] = "cat";
argv[1] = 0;
if(fork() == 0) {
	close(0);
	open("input.txt", O_RDONLY);
	exec("cat", argv);
}

```

在子进程关闭描述符0之后，保证open去使用新打开的input.txt的文件描述符：0是存在的最小的描文件述符。然后，Cat拥有关联input.txt的文件描述符0进行运行。

在xv6的shell中，I/O重定向的代码就是这样工作的。这个时候回想shell调用fork创建子进程的代码，shell和runcmd将调用exec来加载新的程序。现在，为什么将fork和exec分开成独立的系统调用是一个好主意的原因就很清楚了。这种分离性允许shell在将要运行程序之前调整子进程。

虽然fork拷贝文件描述符表，但是每个下层的文件偏移量是在子进程和父进程之间共享的。考虑下面的例子：

```
if(fork() == 0) {
    write(1, "hello ", 6);
    exit();
} else {
    wait();
    write(1, "world\n", 6);
}

```

代码片段的结束，关联文件描述符1的文件将包含数据"hello world"。父进程的write（由于wait，它在子进程完成后运行）接载子进程write剩下的。这种行为有助于从顺序的shell命令，像（echo hello; echo worl）> output.txt 中产生顺序输出。

dup系统调用复制已存在的文件描述符，返回关联到下层同一个I/O对象的新文件描述符。它们共享一个偏移量，就像泰国fork复制文件描述符一样。这是另一种方法写hello world到一个文件：

```
fd = dup(1);
write(1, "hello ", 6);
write(fd, "world\n", 6);

```

通过fork和dup调用继承于同一个原始文件描述符的两个文件描述符共享一个偏移量。其他情况，文件描述符不共享偏移量，即使它们是调用open打开同一个文件获取的。Dup运行shell实现命令：ls existing-file non-existing-file > tmp1 2>&1。2>&1告诉shell去给命令一个描述符2，它是描述符1的复制品。已存在文件的名称和不存在文件的错误信息都在文件tmp1中显示。xv6的shell不支持错误文件描述符的I/O重定向，但是你现在知道怎样去实现它。

文件描述符是强大的抽象，因为它隐藏了它们连接的细节：一个进程向文件描述符1写入也许是写入一个文件，一个像console的设备或者一个管道。

----------------------

管道

一个管道作为一对文件描述符，是一个暴露给进程的很小的内核缓冲区。其中一个描述符为了读取，一个为了写入。向管道的一端写入数据，可以从管道的另一端读取该数据。管道提供了一种进程之间通信的方法。

下面的例子代码运行wc程序，让标准输入连接到管道的读取端。

```
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if(fork() == 0) {
	close(0);
    dup(p[0]);
    close(p[0]);
    close(p[1]);
    exec("/bin/wc", argv);
} else {
	write(p[1], "hello world\n", 12);
	close(p[0]);
	close(p[1]);
}

```

程序调用pipe，它创建一个新的管道，并且在数据p中记录读取和写入的文件描述符。fork之后，父进程和子进程同时拥有关联到管道的文件描述符。子进程将管道的读取端指向文件描述符0，关闭p中的文件描述符，然后运行wc。当wc从它的标准输入读取的时候，它从管道读取数据。父进程向管道的写入端写数据，然后关闭所有的文件描述符。

如果没有数据，一个管道的读取会等待直到数据的写入或者所有关联到写入端的文件描述符被关闭。在后一种情况下，读取会返回0，就像到达了数据文件结尾。read阻塞直到新数据不可能到达的事实是一个重要原因，在wc运行之前子进程关闭管道的写入端的。如果存在一个关联到管道写入端wc的文件描述符，wc将永远不可能达到文件结尾。

xv6的shell实现的管道，比如手册里的：grep fork sh.c | wc -l 类似上面的代码。子进程创建一个管道来连接到管道的左端和右端。然后它调用管道左端的runcmd和右端的runcmd，并且等待左右端结束，通过调用两次wait函数。管道的右端可能是一个自带管道的命令（例如：a|b|c），它自己fork两个新的子进程（一个给b，一个给c）。因此，shell可能创建一棵进程树。树的叶子是命令，中间节点进程会等待直到左右子进程完成。原则上，你可以让中间节点运行管道的左端，但是完全正确实现会带来实现的复杂性。

管道看起来并不比临时文件强大。

管道：

```
echo hello world | wc

```

没有管道的实现:

```
echo hello world >/tmp/xyz; wc </tmp/xyz

```

管道和临时文件存在三个关键不同。第一，管道自动清理自身；文件重定向在完成的时候shell必须小心的移除/tmp/xyz。第二，管道可以传输任意长度的数据流，文件重定向需要足够的空闲磁盘来保存所有数据。第三，管道允许同步：两个进程能使用一对管道来相互发送消息，每个读取阻塞它的调用进程知道另外一个进程通过write发送了数据。

-----------------------------

文件系统

xv6文件系统提供数据文件，它们是非解释的子节数组和文件夹（它包含数据文件和其他文件夹的命名引用）。xv6实现文件夹为一种特殊类型的文件。文件夹形成一棵树，开始于一个称作root的特殊文件夹。一个像“/a/b/c”的路径引用文件或者文件夹，被称作c在文件夹在文件夹b在文件夹a在root文件夹/。不以/开头的的路径，相对于调用进程当前文件夹，它能被chdir系统调用修改。这些代码片段打开同一个文件（假设所有文件夹已经存在）。

```
chdir("/a");
chdir("b");
open("c", O_RDONLY);

open("/a/b/c", O_RDONLY);

```

第一个片段修改当前进程的文件夹成/a/b；第二个既没有关联也没有修改进程的当前文件夹。

存在多个系统调用来创建新文件或者文件夹：mkdir创建新文件夹，带O_CREATE标志的open创建新数据文件，mknod创建新的设备文件。这个例子说明以上三种情况。

```
mkdir("/dir");
fd = open("/dir/file", O_CREATE|O_WRONLY);
close(fd);
mknod("/console", 1, 1);

```

mknod在一个文件系统中创建一个文件，但是这个文件没有内容。替代的，这个文件的元数据标志它是一个设备文件和记录主要和次要的设备号（mknod的两个参数），它唯一决定了一个内核设备。当一个进程后来打开该文件，内核让read和write系统调用改道成内核设备实现来替代把它们给文件系统。

fstat获取关联文件描述符对象的信息。它填充一个stat结构体，定义在stat.h中。

```
#define T_DIR  1
#define T_FILE 2
#define T_DEV  3

struct stat {
    short type;  // Type of file
    int dev;     // File system’s disk device
    uint ino;    // Inode number
    short nlink; // Number of links to file
    uint size;   // Size of file in bytes
};


```

一个文件的名称跟文件本身是由区别的。同一个下层的文件，被称作一个inode，可以有多个名称，被称作links。link系统调用创建另外的文件系统名称，关联到同一个已存在的文件inode。这段代码创建一个新的文件，被命名a和b。

```
open("a", O_CREATE|O_WRONLY);
link("a", "b");

```

读写a跟读写b是一样的。每一个inode被唯一的inode号码标识。在上面的代码执行后，通过检查fstat的结果查明a和b引用同一个下层内容是可能的。a和b的fstat返回同样的inode号码（ino），并且nlink数量被设置成2.

unlink系统调用从文件系统移除一个名称。当文件的link数量等于0并且没有文件描述符引用它的时候，这个文件的inode和装载其内容的磁盘空间会被释放。

因此增加

```
unlink("a");

```

在代码的最后，让inode和文件内容的访问只能通过b。更进一步，

```
fd = open("/tmp/xyz", O_CREATE|O_RDWR);
unlink("/tmp/xyz");

```

是一种符合语言习惯的方法去创建一个临时inode，当进程关闭fd或者停止时，它将被清理。

xv6操作文件系统的命令是作为用户等级程序实现的，例如：mkdir、ln、rm等。这种设计允许任何人去扩展shell的新用户命令。马后炮来讲，这种计划时显而易见的，但是其他跟Unix同时代被设计的系统经常把那些命令在shell里面创建。（并且把shell在内核中创建）。

一个例外是cd命令，它是建立在shell里面的。cd必须修改shell自身的当前工作文件夹。如果cd像常规命令一样执行，那么shell将fork一个子进程，这个子进程将执行cd，并且cd将改变子进程的工作文件夹。父进程（shell）的工作文件夹将不会改变。


------------------------

真实世界

Unix对标准文件描述符、管道和shell操作语法的便利性的结合是在编写通用目的可重用程序中的一个主要进步。这个点燃整个软件工具文化的想法对Unix的强大和流行是有极大用处，并且shell是所谓的第一个脚本语言。Unix的系统调用接口在今天持续存在于像BSD、Linux和Mac OSX这样的系统中。

现代内核比xv6提供更多的系统调用，更多的类型的内核服务。对于大多数部分，现代起源于Unix的操作系统不跟进暴露设备作为特殊文件（就像上面讨论的console设备文件）早期的Unix模型。Unix的作者继续创建计划9，它应用“资源即文件”的概念到当今的场景，将网络，图像和其他资源视为文件或者文件树。

文件系统抽象是一个强大的想法，在WWW形式下大部分都被应用到网络资源。即使是这样，也存在其他的操作系统接口模型。Multics（多路复用系统），一个Unix的前任，抽象文件存储成一个看起来像内存，产生一种非常不同的味道的接口。Multics设计的复杂性对Unix的设计者产生了直接影响，他试着创建更加简单的东西。

这本书检验xv6怎样实现它的类Unix的接口，但是这些想法和概念可以应用到比Unix更多的系统中。任何操作系统进程必须复用底层的硬件，隔离进程和提供可控的进程间通信。学习xv6之后，你必须能看到其他的更加复杂的操作系统，并且同样的看到那些系统中的xv6的设计概念。


2. 操作系统组织（结构）

操作系统一个关键的需求是支持多个活动（任务）。举例，使用第一节的系统调用接口，一个进程可以使用fork开启一个新的进程。操作系统必须管理这些进程能分时共享计算机的资源。举例，一个进程可能会开启超过计算机中处理器数量的新进程，但所有的进程必须能够有一定的执行进度。另外，操作系统必须在进程间管理隔离性。那样，如果一个进程有bug崩溃了，它不能影响没有依赖崩溃进程的进程。但是，完全的隔离太强了，因为进程间有可能相互交互。举例，用户组合多个进程实现复杂的任务是方便的。（通过使用pipe等）因此，操作系统的实现需要满足三种需求：复用性（硬件）、隔离性和交互性。

本节提供一个称作系统是如何组织来满足这三个需求的总览。达到这个目标被证明是由多种方法的，但是本文聚焦于主流设计（宏内核），它被用于多种Unix称作系统。本节通过跟踪xv6启动时创建的第一个进程说明这种组织结构。为了这样做，本文提供xv6提供的所有主要抽象的实现的一瞥，它们是怎样交互的，复用、隔离和交互的三种需求是怎样满足的。xv6的大部分避免特化第一个进程，相反的，重用xv6必须为标准称作提供的代码。随后的章节将更加仔细地探索每一个功能抽象。

xv6运行在Intel 80386 或者 后续型号 (‘‘x86’’)处理器上，在PC平台，并且它的低层的大部分功能是x86-specific。本书假设读者有一定的特定架构机器级别编程的基础，并且在遇到的时候介绍x86-specific知识。附录A简单的概括了PC平台。

------------------------

物理资源抽象

当考虑操作系统的时候，一个人也许要问的第一个问题是为什么要完全的拥有？那是，一个人可以将系统调用作为一个库来实现，应用程序可以链接这个库。这种计划里，每个应用可以有它自己的库，也许被调整以满足它的需求。这种计划里，应用能直接跟硬件资源交互和在最好的方式下使用它们来实现应用需求（实现高性能或者可预期的性能）。一些很小的嵌入式设备的操作系统或者实时系统是被这样组织的。

这种方法的负面影响是应用都是自由的使用库，它意味着它们（应用）也能不使用库。如果它们不使用操作系统库，那么操作系统不能强制分时共享。它必须依赖于应用正确的行为和，举例，周期性的放弃处理器，以便其他应用能运行。对于一个所有应用都相互信任的系统，那样的合作分时共享计划也许是OK的，但是如果应用是相互不信任的，它将不提供强的隔离性。

实现强的隔离性，一个有益的方法是不允许应用直接访问硬件资源，相应的抽象硬件资源成服务。比如，应用跟文件系统交互只通过open、read、write和close系统调用，替代读写原始的磁盘扇区。这种方法提供应用路径名的方便性，并且它允许操作系统（作为接口的实现者）管理磁盘。

类似的，在Unix里应用使用fork作为进程运行，允许操作系统保存和恢复寄存器值在应用切换不同的进程时，如此一来应用不必关心进程的切换。更进一步，它允许操作系统强制切换一个应用离开处理器，如果这个应用，举例，是一个死循环。

另外一个例子，Unix进程使用exec建立它们的内存镜像，替代直接跟物理内存交互。这允许操作系统决定将一个进程放在内存的那个位置和如果内存短缺的时候移动东西，并且提供应用保存它们自身镜像的文件系统方便性。

为了支持可控的应用之间交互，Unix应用能仅使用文件描述符，替换组建它们自己的共享便利（保留一些物理内存）。Unix文件描述符抽象所有的共享细节，隐藏应用如果交互式发生在终端、文件系统、或者管道之间，但是允许操作系统控制交互。举例，如果一个应用崩溃，它能关闭通信通道。

你能看到，系统调用接口是被小心设计去提供编程者方便但同时也为了保证强的隔离性接口的实现。Unix接口不是唯一抽象资源的方法，但它被证明是一种非常好的方法。

---------------------------

用户模式，内核模式和系统调用

为了在使用系统调用的软件和实现系统调用的软件之间提供强的隔离性，我们需要在应用和操作系统之间有一个硬边界。如果应用存在一个错误，我们不想操作系统崩溃。相反的，操作系统能清理该应用并且运行其他应用。这种隔离性意味着应用不能写操作系统维护的数据，和不能覆盖操作系统的指令等。

为了提供那样的强隔离性，处理器提供了硬件支持。举例，x86处理器，像其他许多处理器一样，有两种处理器执行指令的模式：内核模式和用户模式。内核模式下，处理器允许执行特权指令。举例，读写磁盘（或者任何其他的I/O设备）是一个特权指令。如果一个应用在用户模式下企图执行特权指令，那么处理器不会执行这条指令，但会切换到内核模式（如此，软件在内核模式下能清理应用），因为它做了它不能做的事情。应用只能执行用户模式下的指令（数值加法等）和被称作运行在用户空间，但是运行在内核模式下的软件能执行特权指令和被称作运行在内核空间。运行在内核空间（内核模式下）的软件被称作内核。

如果用户模式下的应用必须读写磁盘，它必须进入内核进行读写，因为应用自身不能执行I/O指令。处理器提供了一条特殊的指令来切换处理器从用户模式进入内核模式和从被内核说明的入口点进入内核。（为了这个目的，x86处理器提供int指令）一旦处理器切换到内核模式，内核就能校验系统调用参数，决定应用是否被允许实现请求的操作，然后否定它或者执行它。当切换到内核模式，内核设定入口点就变得很重要了。如果应用能决定内核的入口点，在检验参数等被跳过的地方恶意的应用能进入内核。

--------------------------

内核组织

操作系统的一个关键设计问题是操作系统的那个部分需要运行在内核模式下。一个简单的回答是内核接口是系统调用接口。那是，fork，exec，open，close，read，write等都是内核调用。这个选择意味着整个操作系统的实现运行在内核模式下。这种内核组织被称作宏内核。

在这种组织下，整个操作系统拥有完全的硬件特权运行。这种组织是方便的，因为OS设计者不必决定操作系统的那部分不需要完全的硬件特权。更进一步，操作系统的不同部分可以很简单的进行协作。举例，一个操作系统也许拥有一段能被文件系统和虚拟内存系统共享的缓存。

宏内核组织的一个负面影响是操作系统不同部分的接口经常很复杂（本文的剩下部分我们会看到），并且因此操作系统的开发者会很容易产生一个错误。在宏内核里，一个错误是毁灭性的，因为内核模式中的一个错误将经常导致内核的崩溃。如果内核崩溃，计算机会停止工作，因此所有的应用也崩溃了。这个计算机必须再一次的重启。

为了减少内核错误的风险，OS设计者能让运行在内核模式下的代码量变小。操作系统的大部分功能不需要访问特权指令，并且作为用户等级应用运行，应用通过消息进行交互。这种内核组织形式称作微内核。

文件系统作为用户等级应用运行。操作系统中作为普通用户程序运行的服务称作服务器。为了允许应用跟文件服务器交互，内核提供一个从一个用户模式应用向另一个发送消息的最小机制。举例，如果一个像shell的应用想读写一个文件，它发送一个消息到文件服务器并且等待一个响应。

在一个微内核中，内核接口由一些低级别的功能（启动应用、实现I/O、向应用发送消息等）组成。这种组织允许内核被很少量的代码实现，因为它不做很多事情，大部分操作系统功能被用户级别的服务器实现。

在真实世界里，人们能找到宏内核和微内核两种形式的内核。举例，linux大部分被实现成宏内核，即使一些OS功能作为用户级别的服务器运行（窗口系统）。xv6被实现成宏内核，跟随大部分的Unix操作系统。因此，在xv6里，内核接口就是操作系统接口，并且内核实现整个操作系统。因为xv6不提供很多功能，它的内核比一些微内核更小。


-----------------------------

进程概览

在xv6（在其他Unix操作系统中也是）中隔离的单元是进程。进程抽象阻止一个进程毁坏或影响另一个进程的内存，CPU，文件描述符等。它同样阻止进程毁坏内核自身。（阻止内核强制隔离）。内核必须小心的实现进程抽象，因为一个bug或者恶意的应用可能欺骗内核或者硬件做一些坏事情（避开强制隔离等）。内核使用的实现进程的机制包含用户/内核模式标志，地址空间，和线程的时间片。

为了实现强制隔离，一个进程是一个抽象（提供说明程序有自己的抽象机器）。进程说明程序哪些出现在私有内存系统中，或者地址空间，哪些其他的进程不能读写。一个进程也说明了程序的哪些部分出现在他自己的CPU去执行程序的指令。

xv6使用页表（它是被硬件实现的）去给每个进程自己的地址空间。x86页表转换（或者映射）一个虚拟地址（x86指令操作的地址）成一个物理地址（处理器芯片发送给主存的地址）。

xv6为每个进程维护一张独立的页表来定义进程的地址空间。一个地址空间包含进程的从虚拟地址0开始的用户内存。首先是指令，紧跟全局变量，然后是栈，最后是一段进程根据需求可扩展的堆区域（malloc）。

每个进程的地址空间映射内核的指令和数据就像用户程序的内存一样。当一个进程行使一个系统调用的时候，系统调用运行在进程的地址空间内核映射中。存在这种安排，因此内核系统调用代码能够直接引用用户内存。为了保留空间给用户内存的增长，xv6的地址空间映射内核到开始于0x80100000的高地址。

xv6维护每个进程的多种状态，它搜集在一个proc结构体中。一个进程最重要的内核状态是它的页表，它的内核栈，和它的运行状态。我们将使用表达式p->xxx来引用proc结构体的元素。

每个进程都有一个运行的线程（或者缩写成线程），它运行进程的指令。一个线程可以被挂起，并且之后恢复。为了透明的切换进程，内核挂起当前正在运行的线程并且恢复另外一个进程的线程。一个线程的大部分状态（局部变量，函数调用的回调地址）被保存在线程栈中。每个进程有两个栈：一个用户栈和一个内核栈（p->kstack）。当一个进程执行用户指令，仅使用它的用户栈，它的内核栈是空闲的。当一个进程进入内核（为了系统调用或者中断），内核代码运行在进程的内核栈上；当一个进程在内核中，它的用户栈仍然包含之前保存的数据，但是它不是活动被使用的。一个进程的线程交替使用它的用户栈和内核栈。内核栈是隔离的（并且被保护着不能被用户代码使用），所以即使在一个进程已经毁坏了它的用户栈时内核仍然能运行。

当一个进程行使一个系统调用时，处理器切换到内核栈，提升硬件特权级别，并开始执行内核中实现系统调用的指令。当系统调用完成后，内核返回用户空间：硬件降低它的特权级别，切换到用户栈，并恢复执行用户指令（在系统调用之后的指令）。一个进程的线程能阻塞在内核中等待I/O，并当I/O结束时恢复。

p->state暗示进程是否被分配、准备执行、正在执行、等待I/O或者停止。

p->pgdir装载进程的页表，x86硬件希望的格式。当执行某个进程的时候，xv6会引起分页硬件去使用进程的p->pgdir。一个进程的页表也服务于被分配存储进程内存的物理页的地址记录。

------------------------------

第一个地址空间

为了让xv6的组织结构（架构）更加具体，我们将看到内核是怎样创建它自己的第一个地址空间的，内核是怎样创建和运行第一个进程的，和它创建的进程是如何行使第一个系统调用的。通过跟踪这些操作我们将细粒度的看到xv6是怎样为进程提供强隔离性的。提供强隔离性的第一步是设置内核运行在它自己的地址空间。

当一台PC通电，它初始化它自己，然后从磁盘加载一个boot loader到内存中，并且运行它。附录B解释了细节。xv6的boot loader从磁盘加载xv6的内核并从entry开始运行它。在内核开始运行的时候，x86的分页硬件还未开启。虚拟地址直接映射到物理地址。

boot loader加载xv6内核到内存的物理地址0x100000。不加载内核到0x80100000地址的原因，内核期望在这个地方找到它的指令和数据，是在小的机器上物理内存中不存在那样高的地址。放置内核在0x100000而不是0x0的原因是因为地址范围：0xa0000:0x100000包含I/O设备。

为了允许剩下的内核代码去执行，entry设置一张页表，它映射从0x80000000开始的虚拟地址（被称作KERNBASE）到从0x0开始的物理地址。设置虚拟地址的两个范围映射到同一个物理地址范围是页表的常用使用方法，我们将看到更多这样的例子。

entry的页表被定义在main.c中。我们将在第二节详细研究页表，短故事是entry 0映射虚拟地址0:0x400000到物理地址0:0x400000。这个映射在entry运行时就需要，但是最终会被移除。

entry 512映射虚拟地址KERNBASE:KERNBASE+0x400000到物理地址0:0x400000。这个entry在entry函数完成后将被内核使用。它映射高虚拟地址(内核期望找指令和数据的地方)到低物理地址（内核被boot loader加载的地方）。这种映射限制内核的指令和数据在4M子节大小。

返回到entry函数，它加载entrypgdir的物理地址到控制寄存器%cr3中。分页硬件必须知道entrypgdir的物理地址，因为它还不知道怎样翻译虚拟地址。它还没有页表。符号entrypgdir关联到一个高内存地址，并切宏V2P_WO减去KERNBASE为了找到物理地址。为了使分页硬件有效，xv6在控制寄存器%cr0中设置成标志CR0_PG。

在分页有效（它从entrypgdir映射低地址之后开始工作）之后，处理器仍然在低地址运行指令。如果xv6从entrypgdir中已经删除了entry 0，计算机尝试在分页有效之后运行指令的时候将会崩溃。

现在entry函数需要转移到内核的C代码，并且在高内存中运行它们。首先，它让栈指针，%esp，指向将被用作栈的内存区域。所有的符号有高地址，包括栈，因此栈将会有效即使低映射被移除了。最后，entry跳转到main函数，它也是一个高地址。这个间接跳转使被需要的，因为不这样的话汇编器默认将会生成一个PC指针相对的直接跳转，它将运行低内存版本的main函数。main不能返回，因为在栈上没有返回的PC指针。现在，内核运行在高地址的main函数中。

-----------------------------

创建第一个进程

现在内核运行在它自身的地址空间中，我们将看到内核是怎样创建用户级别的进程，并且在内核和用户进程和用户进程之间保证强隔离性的。

在main初始化多个设备和子系统之后，它调用userinit创建第一个进程。userinit的第一个动作是调用allocproc函数。allocproc的职责是在进程表中分配插槽（一个proc结构体）并且初始化内核线程运行需要的进程状态部分。allocproc被每个新进程调用，userinit只被第一个进程调用。allocproc为了找到一个状态为UNUSED的插槽扫描proc表。当它找到一个没有被使用的插口，allocproc设置它的状态成EMBRYO，以表示它被使用了，并且给进程一个唯一的pid。下一步，它试着为进程的内核线程分配内核栈。如果内存分配失败，allocproc改回它的状态成UNUSED并且返回0表示失败。

现在，allocproc必须设置新进程的内核栈。allocproc被写成既能被fork使用也能被创建第一个进程的时候使用。allocproc设置新进程给它一个特殊准备的内核栈并且设置内核寄存器成当它第一次运行的时候返回到用户空间。这个特殊准备的内核栈的布局将被展示。allocproc做了部分这样的工作，它设置返回的pc指针值让新进程的内核线程第一次运行在forkret中，然后运行trapret。内核线程将会运行，它的寄存器内容是拷贝p->context的。因此，设置p->context->eip成forkret将导致内核线程开始运行forkret函数。这个函数将返回栈底任何的地址。上下文（context）切换代码设置栈指针（esp）指向p->context之后的地方。allocproc放置p->context在栈上，并且放置一个指向trapret的指针在它之上。它是forkret返回的地方。trapret从保存在内核栈顶的值恢复用户寄存器，并且跳转到进程。这种设置跟普通的fork调用和创建第一个进程是一样的，因此在之后的例子里进程进程将开始运行在用户地址空间地址0，而不是从fork返回的地方。

我们将在章节3中看到，通过一个中断机制控制用户软件转换成内核的方法，它被用在系统调用，中断和异常中。在进程运行期间任何时候转入内核，硬件和xv6陷阱进入代码保存用户寄存器在进程的内核栈上。如果进程通过中断已经进入了内核，userinit将写入数值到新栈栈顶，就像它们就在哪一样。如此一来，普通代码从内核返回进程的用户代码将会正常工作。这些数值是一个trapframe结构体，它保存了用户的寄存器数值。现在新进程的内核栈完全准备好了。

第一个进程将会运一段小的程序（initcode.S）。进程需要物理内存保存这段程序，程序需要被拷贝到那段内存，并且进程需要页表关联到那段内存。

userinit调用setupkvm创建一张页表为进程映射内核使用的内存。我们将会在第二节详细讲解这个函数，但是在宏观上setupkvm 和 userinit 创建了一个地址空间。

第一个进程的内存初始化内容被编译在initcode.S中。作为内核创建进程的一部分，连接器将这个二进制嵌入到内核中，并且定义两个特殊的符号，binary_initcode_start 和 bina-ry_initcode_size,表示二进制的位置和大小。userinit调用inituvm来将二进制拷贝到新进程的内存中，它分配了一张页表的物理内存，映射虚拟地址0到那段内存，然后拷贝二进制到那张表中。

然后，userinit设置自带初始化的用户模式状态的trap帧：%cs寄存器包含段选择器（SEG_UCODE段在特权级DPL_USER运行，用户模式而非内核模式），并且类似的%ds, %es, 和 %ss寄存器使用SEG_UDATA段（DPL_USER特权级）。%ef标志FL_IF位被设置成允许硬件中断。我们将在章节3中重新检验这一点。

栈指针%esp被设置成进程的最大有效虚拟地址，p->sz。指令指针被设置成initcode的入口点，地址0。

函数userinit设置p->name成initcode主要是为了调试debug。p->cwd设置进程当前的工作文件夹。我们将在章节6仔细检查namei函数。

一旦进程被初始化了，userinit通过设置p->state成RUNNABLE来让它能够被调度。


--------------------------------

运行第一个进程

现在第一个进程的状态被准备好了，是时候去运行它了。在main调用userinit之后，mpmain调用scheduler去开始运行进程。scheduler寻找p->state被设置成RUNNABLE的进程，现在只有一个，initproc。它设置每一个cpu的变量proc成那个它找到的进程，并且调用switchuvm告诉硬件开始使用目标进程页表。在内核中运行的时候改变页表是可以的，因为setupkvm使所有的进程的页表拥有内核代码和数据的相同的映射。switchuvm也设置任务状态段SEG_TSS成硬件去执行系统调用和中断在进程的内核栈上。在章节3中我们将重新检查任务状态段。

scheduler现在设置p->state成RUNNING和调用swtch去实现上下文切换到目标进程内核线程。swtch保存当前寄存器和加载保存的的目标内核线程的寄存器（proc->context）到x86的硬件寄存器，包括栈指针和指令指针。当前的上下文不是一个进程但是是一个特殊的每个cpu的调度器上下文。因此scheduler告诉swtch保存当前硬件的激素存起在每个cpu的存储区（cpu->scheduler）而不是任意进程的内核线程上下文。在章节5我们将详细检查swtch函数。最后的ret指令从栈中弹出目标进程的%eip，结束上下文切换。现在处理器运行在进程p的内核栈。

allocproc设置initproc的p->context->eip指向forkret，因此ret开始运行forkret。在第一次调用的时候，forkret运行初始化函数（它不能从main中运行）因为它必须在包含内核栈的常规进程的上下文下运行。然后forkret返回。Allocproc安排p->context之后的栈顶word被弹出成trapret，因此trapret开始执行，这时%esp被设置成p->tf。Trapret使用pop指令来从trap帧恢复寄存器，就像swtch对内核上下文做的一样：popal 恢复通用寄存器，然后popl指令恢复%gs, %fs, %es, 和 %ds。addl跳过两个字段trapno和errcode。最后，iret指令从栈中弹出%cs, %eip, %flags, %esp, 和 %ss。陷阱帧的内容被转换成CPU的状态，因此处理器继续执行%eip指向的代码（被陷阱帧说明的%eip）。对于initproc，那意味着虚拟地址0，initcode.S的第一条指令。

这个时候，%eip是0， %esp是4096。它们是进程地址空间的虚拟地址。处理器的分页硬件转换它们到物理地址。allocuvm设置进程页表，因此虚拟地址0关联到为进程分配的物理内存，并且设置标志PTE_U告诉分页硬件允许用户代码访问那段内存。userinit设置%cs的低位来运行进程代码（CPL=3）的事实意味着用户代码只能使用标志PTE_U的页，并且不能修改敏感的硬件寄存器，例如%cr3。因此，进程被限制成只能使用它自己的内存。

-----------------------

第一个系统调用：exec

现在我们看到了内核是如何为进程提供强隔离性的，让我们再看看用户进程是如何进入内核去获取它自己不能实现的服务的。

initcode.S的第一个动作是调用exec系统调用。在章节0中我们已经看到，exec用新的程序替换当前进程的内存和寄存器值，但是它保留文件描述符，进程id和父进程的不作改变。

Initcode.S开始push是那个数值到栈上：$argv, $init, 和 $0，然后设置%eax成SYS_exec，然后运行int T_SYSCALL：它让内核执行exec系统调用。如果所哦鱼的正常执行，exec将不会返回：它开始运行被称作$init的程序，它是一个指向非中断的字符串/init的指针。如果exec失败和返回，initcode循环调用exit系统调用，它不需要返回。

exec调用的参数是$init 和 $argv。最后的0让这个手写的系统调用看起来就像普通的系统调用，第三节可以看到。在以前，这种设置避免特化第一个进程（在这个例子里，它的第一个系统调用），并且替代成xv6必须提供的标准操作的重用代码。

章节2将详细讲解exec的实现，但是在宏观上它替换initcode成/init二进制，从文件系统中加载的。现在的initcode完成了，进程将运行/init。init如果必要将创建一个console设备文件，然后作为文件描述符0、1、2打开它。然后它循环，开始一个console的shell，处理孤立的僵死进程直到shell结束，和重复。系统起来了。

----------------------------

真实世界

大多数操作系统采用了进程概念，和大多数进程像xv6的进程。一个真实的操作系统的将在详细的空闲的列表中找到闲置的proc结构体，用常量时间来代替线性搜索时间在allocproc里。xv6使用线性扫描为了简单性。

xv6的地址空间布局有一个缺陷：不能使用超过2GB的物理RAM。它是可以被修复的，即使最好的计划是切换到一个64位机器。


>END


