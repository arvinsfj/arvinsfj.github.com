C的一些技巧：
1、宏和enum类型定义，可以不需要定义数据类型，提供了类型适配的可能；enum也可以作为连续常数批量定义，代替宏定义；
2、位运算性能快于其他运算，主要使用移位代替乘除，按位或和与代替加减，异或代替等于和不等于，++和--代替变量自身+1和-1；
3、找出公共变量（表达式），并只计算一次表达式，结果保存在公共变量中；
4、使用数据常量表优于动态生成常量；
5、数组下标代替条件判断；
6、定义常量宏同时定义宏中的位常量；使用宏抽象表达式；巧妙使用宏的#和##；
7、函数定义中函数名称可以理解成一个地址常量；
8、减少运算符号或使用更高效的运算符号；比如：return v+=0x1000；等价于 return v+0x1000;  (v&0x7000)==0x7000 等价于 (v&0x7000)^0x7000； v&=0x8000;v&=0x0C1F;等价于v&=0x8C1F; (addr-0x2000)&7;等价于addr&7;
9、识记常用的运算符优先级，可以减少很多的()，让代码变得干净；优先使用u_int8等代替unsigned char；优先使用typedef来定义构造类型； 优先使用变量初始化赋值；数组或指针变量赋值中使用++或--；使用简写的赋值语句；使用正向逻辑编码；
10、向结构体中传递函数指针来定义“接口”；（类似OOP中接口的作用）
11、使用const和static来限制变量和方法的访问权限，时刻提醒自己；对于性能瓶颈部分的函数或变量可以使用register；
12、extern可以让函数的使用变的轻松；头文件中只提供必要的宏定义、类型定义（结构体等）、对外接口函数定义，不要提供数据的实现、函数的实现等，不要给自己找麻烦；
13、return c++; 这是错误的，你永远得不到你想要的，请换成return ++c;
14、for和while中不要定义变量，除非这个变量定义成static；变量定义请放置for和while的外面；
15、函数中优先使用局部静态变量（函数中的static变量），代替全局变量；提高可读性和稳定性；
16、数据交换:a=a^b;b=b^a;a=a^b; 数据运算：a*16+5 等价于 a<<4|5
17、变量运算中时刻注意变量类型的取值范围；巧妙使用类型范围的wrap特性，减少运算；
18、变量类似于内存地址，表达式重要的是运算符即CPU运算，表达式中的变量和运算结果都保存在CPU寄存器中，赋值运算是将寄存器中的表达式运算结果写入变量代表的内存中；这也是赋值运算右边最终必须是变量而不能是表达式的原因；赋值表达式的值是右边变量的最终数值；将赋值表达式作为表达式而非语句，只要使用(赋值表达式)形式，可以嵌入条件表达式中；
19、uint16_t bit = 1<<x; 与 uint16_t bit = 1<<(15 - x); 是对称取位数值；掩码生成：(1 << x) - 1;
20、C中非0即为true，-1也代表true；n == 0;等价于!n; n != 0;等价于n;
21、注意C中的除法，整除和float的除法；整除会丢弃余数的;
22、使用共用体定义共用内存块，简化部分字节的获取和存储；最经典的莫过于对x86寄存器的模拟，比如AX、AH、AL等；
23、使用宏替换来简化代码，比如：#define c(n) Ins<0x##n>,Ins<0x##n+1>, #define o(n) c(n)c(n+2)c(n+4)c(n+6) static void(*const i[0x10])() = { o(00)o(08) } #undef o #undef c
24、使用字符串和宏来定义常量表；非常巧妙，代码非常简洁，但可读性不好；类似base64编码，用字符表示数值；可以认为是代码中的数据编码压缩方法；
25、编程中注意层次划分；比如：C语法元素（数组、结构体、循环等）、C标准库（API跨平台）、C平台相关库（pthread、socket等）、C第三方库（有跨平台的也有平台相关的）；同时代码自身层次也要区分清楚；
26、使用C你可以拿到程序运行时的各种数据，比如：运行时的变量内存地址等等；C给了你所有的东西，就看你自己怎么使用了；

C++对C的扩展(c++11)：
1、头文件引进的改变，可以不带.h
2、增加了一些标准库，比如：STL、iostream、algorithm、正则表达式、string、线程、元组、只能指针、包装引用等
3、函数模版和类模板（class 和 struct），模版里面可以定义常量数值和类型
4、引入类型推断（auto关键字、decltype关键字、c++11）
5、增加了函数参数和返回值的引用类型（C中需要使用指针来实现相同功能）
6、增加了命名空间和类（封装、继承、多态、访问权限等）
7、增加了函数重载和运算符重载；基本可以认为运算符就是函数名称；
8、增加了匿名函数支持；也就是闭包的支持；
9、支持二进制常量表示；nullptr替代NULL；
10、新增右值引用，左值和右值都是针对表达式而言的，左值是指表达式结束后依然存在的持久对象，右值是指表达式结束时就不再存在的临时对象；
11、新增原生字符串表示：string raw = R"(c:\Windows\System32\cmd.exe)"; 取消字符转义功能；
12、新增char类型：char16_t 和 char32_t ，以及 u16string 和u32string；存储 utf-16 和 utf-32 编码的字符串；
13、支持for-:结构的循环语法；int a[3] = {1, 2, 3};for (int &i : a){cout<<i;}
14、简化成员变量初始化，像普通变量一样；
15、c++11控制默认成员函数是否生成；（构造、析构等）
16、新的变量初始化方法：int i {1}; int a[] {2, 3};
17、delete多个变量；int * a = new int; double * b = new double; delete a, b;
18、子类调用父类构造方法的新方法；using B2::B2;
19、新增override和final关键字；
20、cout、new、delete替换C中的printf、malloc和free；

一些思考：
1、程序本质是基于图灵机进行逻辑表达和操作数据；而事物的逻辑可以通过书写符号来进行表达；
2、现代编程语言，逻辑包含三种结构：顺序、循环和条件跳转；通过表达式来计算驱动条件和操作数据；
3、逻辑表达和逻辑运行，是有很大差别的。我们编写的程序可以认为是逻辑表达，而编译成的可执行文件的运行才是逻辑的运行；
4、逻辑运行可能非常复杂，远超人脑可达到的程度；但逻辑表达可能非常简单；
5、如何编写出逻辑运行非常复杂的逻辑表达才是编程的难处所在；技巧在于逻辑精确分解和精确表达，做到不多不少；递归和循环的终止条件分析、子结构分析；（分析是忽略重复操作，关注跳出操作）
6、程序设计就是兼顾性能和内存的情况下，做到逻辑的精确表达；程序设计更倾向于艺术，更多的是自我智慧的表达；
7、当然逻辑本身也可以是自我表达，比如独立游戏、AI算法等；
