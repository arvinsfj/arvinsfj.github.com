# 如何在C代码中执行机器指令（osx平台）
-----------------------------------------

该篇研究在C中嵌入机器代码进行编译和执行。一般情况下，C中最多只能嵌入汇编代码，进行编译。想法来自，C函数中能不能定义C函数。按照常规思维，C的语法是不允许在函数内部定义函数的。

#### 一、基本思路

C不允许的话，那就看汇编，内联汇编写函数很麻烦。从而，想起了机器代码。一个思路是把C函数编译成机器代码，然后把机器代码嵌入C的函数中，这样就是C函数中定义函数了。（虽然该函数不是C语言定义的，但是是等效的）

#### 二、基本步骤

1. 编写C源代码

```
#include <stdio.h>

void mia()
{
	 static char vk = 'a';
	 printf("%d\n", vk);
}

void miba()
{
    mia();
}

void mic()
{
    /*
    for (int i = 0; i < mic-miba; i++) {
        printf("\\x%02x", ((unsigned char*)miba)[i]);
    }*/
    void* sc = "\x55\x48\x89\xe5\xe8\x49\xff\xff\xff\x5d\xc3\x0f\x1f\x44\x00\x00";
    ((void (*)())sc)();
}

int main(int argc, char** argv)
{
	mia();
    mic();
	return 0;
}

```
上面的代码，包含四个函数，mia打印静态变量vk，miba调用mia函数，mic是我们的特殊函数（里面含有机器代码），main是主函数（系统调用程序的入口）。

2. 使用GCC编译：gcc test.c -o test

3. 使用反汇编工具：otool -tv test 显示汇编码

```
text_exec:
(__TEXT,__text) section
_mia:
0000000100000ef0	pushq	%rbp
0000000100000ef1	movq	%rsp, %rbp
0000000100000ef4	subq	$0x10, %rsp
0000000100000ef8	leaq	0x9b(%rip), %rdi
0000000100000eff	movsbl	0x112(%rip), %esi
0000000100000f06	movb	$0x0, %al
0000000100000f08	callq	0x100000f78
0000000100000f0d	movl	%eax, -0x4(%rbp)
0000000100000f10	addq	$0x10, %rsp
0000000100000f14	popq	%rbp
0000000100000f15	retq
0000000100000f16	nopw	%cs:(%rax,%rax)
_miba:
0000000100000f20	pushq	%rbp
0000000100000f21	movq	%rsp, %rbp
0000000100000f24	callq	0x100000ef0
0000000100000f29	popq	%rbp
0000000100000f2a	retq
0000000100000f2b	nopl	(%rax,%rax)
_mic:
0000000100000f30	pushq	%rbp
0000000100000f31	movq	%rsp, %rbp
0000000100000f34	subq	$0x10, %rsp
0000000100000f38	leaq	0x5f(%rip), %rax
0000000100000f3f	movq	%rax, -0x8(%rbp)
0000000100000f43	movb	$0x0, %al
0000000100000f45	callq	*-0x8(%rbp)
0000000100000f48	addq	$0x10, %rsp
0000000100000f4c	popq	%rbp
0000000100000f4d	retq
0000000100000f4e	nop
_main:
0000000100000f50	pushq	%rbp
0000000100000f51	movq	%rsp, %rbp
0000000100000f54	subq	$0x10, %rsp
0000000100000f58	movl	$0x0, -0x4(%rbp)
0000000100000f5f	movl	%edi, -0x8(%rbp)
0000000100000f62	movq	%rsi, -0x10(%rbp)
0000000100000f66	callq	0x100000ef0
0000000100000f6b	callq	0x100000f30
0000000100000f70	xorl	%eax, %eax
0000000100000f72	addq	$0x10, %rsp
0000000100000f76	popq	%rbp
0000000100000f77	retq

```
完整的汇编码可以使用：gcc -S test.c -o test.s

```
	.section	__TEXT,__const
l_.str.1:                               ## @.str.1
	.asciz	"UH\211\345\350I\377\377\377]\303\017\037D\000\000"
	
```
注意我们的机器代码字符串常量，被定义到了__TEXT段。使用：otool -lv test 可以知道 __TEXT段具有执行权限。

```
Load command 1
      cmd LC_SEGMENT_64
  cmdsize 552
  segname __TEXT
   vmaddr 0x0000000100000000
   vmsize 0x0000000000001000
  fileoff 0
 filesize 4096
  maxprot rwx
 initprot r-x
   nsects 6
    flags (none)

```

换句话来讲，我们把机器代码（二进制）定义成常量字符串（使用16进制的转义字符表示），被调用后就可以执行了。

接下来考虑，如何得到一个C函数的机器代码的常量字符串。我们拿miba函数作为例子使用。通过vi拿到对应函数的字节的16进制表示是可以的。由于代码区具有可读可执行的权限，所以也可以使用C的打印函数打印出来C函数的机器代码常量字符串。

4. 使用：vi test 打开二进制文件，并使用:%!xxd子命令格式化显示二进制（%!xxd -r子命令取消格式化）

可以查看miba函数的机器代码。

5. 使用C函数打印C函数的机器代码

```
for (int i = 0; i < mic-miba; i++) {
    printf("\\x%02x", ((unsigned char*)miba)[i]);
}

```

注意这个地方的写法与函数定义的位置有关。起点是函数名称（也就是函数的指针）miba，终点是mic函数指针。这里是根据函数在机器代码中的地址位置跟C代码中的位置顺序一致。
callq指令是e8，e8后面4个字节是跳转的地址偏移量，这个偏移量是相对于callq这条指令的下一条指令的地址（即IP寄存器中的地址）。
由于机器代码字符串存放位置，跟miba函数机器代码存放位置并不在同一个地址，所以我们自己要计算出机器代码字符串中e8指令的偏移量。如何计算呢？

使用：vi test 打开二进制文件，并找到常量字符串e8指令的地址位置，该位置加上5就是下一条指令的位置（IP寄存器中的地址），该地址加上e8地址偏移量需要等于mia函数的入口地址。
这些所有的信息都可以在vi打开的可执行二进制文件中找到。最后需要将，e8的后4个字节替换成我们自己计算出来的偏移量字节（注意小端序问题和加法溢出问题）。

![执行结果](http://arvinsfj.github.io/public/ctt/documents/testasm/mc.png)

```
\x55\x48\x89\xe5\xe8\xc7\xff\xff\xff\x5d\xc3\x0f\x1f\x44\x00\x00
```
替换成
```
\x55\x48\x89\xe5\xe8\x49\xff\xff\xff\x5d\xc3\x0f\x1f\x44\x00\x00
```

偏移量 + 0xfa7 = 0xef0，考虑进位溢出可以得到偏移量等于0xf49，写成小端序即，\x49\xff\xff\xff。

到此，我们程序的机器指令函数修改好了，接下来需要调用该函数。

使用:
```
((void (*)())sc)();
```

这就是全部的逻辑。在mic中调用sc函数，sc函数中调用mia函数。也就是说，sc函数跟miba函数等价。

从上面的形式上来讲， 就是在mic函数中定义了一个内部函数sc。功能上也是一样的，内部函数只能在定义函数中使用，只暴露给定义函数。

虽然，可以实现内部函数定义，但是机器代码的地址偏移量跟sc常量字符串的位置相关，二常量字符串的位置跟C文件的定义相关。即，可以实现但是耦合性太强。目前还没有找到好的方法解决该问题。

最后贴上执行效果：

![执行结果](http://arvinsfj.github.io/public/ctt/documents/testasm/mcr.png)

注意mia函数被调用了两次。

OK，你对可执行文件更加了解了。GET新技能！


#### 三、话语

1. 我不知道这算不算mach-o格式的一个漏洞，能不能被利用。（栈上可执行，导致了缓冲区溢出漏洞，这个也有这种意思）
2. 指令跟数据本质上是一样的，指令是数据，数据也可以是指令。但必须具有可执行权限
3. 相同的CPU的机器码是一样的，能不能通过这种方法来支持跨平台
4. 在LoadCommand中可以修改__DATA段的权限，让它可读可写可执行，这就提供了一种动态控制程序执行流程的方法（待尝试）
5. 字节是计算机能处理的最小单位，计算机内的所有东西都是用字节来表示的。只是不同的规范赋予字节文件不同的含义和使用方法。

---------------------------------------------

END

