# 如何编辑可执行文件（osx平台）
-----------------------------------------

接着上一篇《如何修改可执行文件》，这篇回答了如何添加和删减机器指令。在可执行文件中添加新指令，比修改原有指令操作数地址和数据资源要难一些，涉及函数入口地址的修改（主函数、库函数、自定义函数），以及Load Command中代码段的起始地址、大小、偏移量的修改。如果需要调试还要简单修改一下符号表的对应地址，这一步不是必须的，不修改也可以正常运行。

#### 一、基本思路

我只演示添加新指令，删减指令的过程相反。mach-o文件，由文件头、加载命令、程序机器码组成（文件尾部还有一些其他东西，比如符号表等）。文件头不需要动（可执行程序的一些描述），加载命令（Load Command）需要修改代码段的内存映射（起始地址、大小、偏移量），其主要是定义机器码的内存映射关系（包括程序和库程序），还需要修改程序的入口地址（main函数的起始地址）。最后需要修改程序的机器码（添加新指令），通过观察编译器编译出来的机器码规律，新增指令代码段是向上增加的，也就是程序指令的起始地址会减小。（如果熟悉mach-o文件可以知道程序代码段的上面有很大一部分空闲区域可以使用）。技巧上我们只减小程序的起始地址，并保持程序的结束地址不变。（结束地址后面是库函数调用的指令，我们尽量保持不变）

#### 二、基本步骤

1. 编写C源代码

```
#include <stdio.h>

void max(int a, int b)
{
    int k = a>=b?a:b;
    putchar(k);putchar('\n');
}

void hello()
{
    printf("hello, world!\n");
}

int main(int argc, char** argv)
{
    hello();
    max(12, 34);
    max(12, 101);
    return 0;
}

```
上面的代码，包含三个函数，max打印两个数的较大者，hello打印字符串“hello, world!”，main是主函数（系统调用程序的入口）。

2. 使用GCC编译：gcc test.c -o test

3. 使用反汇编工具：otool -tv test 显示汇编码

```
test:
(__TEXT,__text) section
_max:
0000000100000ec0	pushq	%rbp
0000000100000ec1	movq	%rsp, %rbp
0000000100000ec4	subq	$0x20, %rsp
0000000100000ec8	movl	%edi, -0x4(%rbp)
0000000100000ecb	movl	%esi, -0x8(%rbp)
0000000100000ece	movl	-0x4(%rbp), %esi
0000000100000ed1	cmpl	-0x8(%rbp), %esi
0000000100000ed4	jl	0x100000ee5
0000000100000eda	movl	-0x4(%rbp), %eax
0000000100000edd	movl	%eax, -0x10(%rbp)
0000000100000ee0	jmp	0x100000eeb
0000000100000ee5	movl	-0x8(%rbp), %eax
0000000100000ee8	movl	%eax, -0x10(%rbp)
0000000100000eeb	movl	-0x10(%rbp), %eax
0000000100000eee	movl	%eax, -0xc(%rbp)
0000000100000ef1	movl	-0xc(%rbp), %edi
0000000100000ef4	callq	0x100000f78
0000000100000ef9	movl	$0xa, %edi
0000000100000efe	movl	%eax, -0x14(%rbp)
0000000100000f01	callq	0x100000f78
0000000100000f06	movl	%eax, -0x18(%rbp)
0000000100000f09	addq	$0x20, %rsp
0000000100000f0d	popq	%rbp
0000000100000f0e	retq
0000000100000f0f	nop
_hello:
0000000100000f10	pushq	%rbp
0000000100000f11	movq	%rsp, %rbp
0000000100000f14	subq	$0x10, %rsp
0000000100000f18	leaq	0x85(%rip), %rdi
0000000100000f1f	movb	$0x0, %al
0000000100000f21	callq	0x100000f72
0000000100000f26	movl	%eax, -0x4(%rbp)
0000000100000f29	addq	$0x10, %rsp
0000000100000f2d	popq	%rbp
0000000100000f2e	retq
0000000100000f2f	nop
_main:
0000000100000f30	pushq	%rbp
0000000100000f31	movq	%rsp, %rbp
0000000100000f34	subq	$0x10, %rsp
0000000100000f38	movl	$0x0, -0x4(%rbp)
0000000100000f3f	movl	%edi, -0x8(%rbp)
0000000100000f42	movq	%rsi, -0x10(%rbp)
0000000100000f46	callq	0x100000f10
0000000100000f4b	movl	$0xc, %edi
0000000100000f50	movl	$0x22, %esi
0000000100000f55	callq	0x100000ec0
0000000100000f5a	movl	$0xc, %edi
0000000100000f5f	movl	$0x65, %esi
0000000100000f64	callq	0x100000ec0
0000000100000f69	xorl	%eax, %eax
0000000100000f6b	addq	$0x10, %rsp
0000000100000f6f	popq	%rbp
0000000100000f70	retq
```
完整的汇编码可以使用：gcc -S test.c -o test.s

4. 使用：vi test 打开二进制文件，并使用:%!xxd子命令格式化显示二进制（%!xxd -r子命令取消格式化）

vi中打开的二进制地址跟反汇编中的地址是一致的。

5. 在vi中新增机器码指令

![机器码](http://arvinsfj.github.io/public/ctt/documents/testasm/jqm1.png)

我们新增16字节的指令机器码，为了方便我在main函数中新增hello函数的调用指令"callq 偏移地址"。并且为了不干扰main函数中的其他指令运算，我在main的结尾处（最后面）新增机器指令。

首先我们可以知道程序的开始和结束地址分别是：0x100000ec0 和 0x100000f70。为了腾出新增指令的存储空间，需要把"0x100000ec0"到"0x100000f50"的机器码整体向上移动16字节（我们新增16字节的机器码，这个可执行文件的代码段是低4位对齐的），移动方法是在vi中修改地址标号即可。然后在"0x100000f50"一行进行机器指令添加。注意修改后的程序开始地址是"0x100000eb0"，结束地址不变还是"0x100000f70"，注意由于字节对齐的关系，下一条指令的开始地址是"0x100000f72"。

![机器码](http://arvinsfj.github.io/public/ctt/documents/testasm/jqm2.png)

首先我们要把上一行的指令补全，即把下一行"0x100000f60"行对应位置的指令复制到"0x100000f50"行的对应位置。并且需要保留"0x100000f60"行的后7个字节数据，确保"0x100000f70"行的程序指令完整。这样空出来的16字节空间地址是0x100000f59-0x100000f68。

![机器码](http://arvinsfj.github.io/public/ctt/documents/testasm/jqm3.png)

接下来在0x100000f59-0x100000f68空间填写我们需要新增的机器码。hello调用机器码是：e8+4字节主机序偏移地址。注意由于机器码整体上移16字节我们的hello函数的入口地址变成了"0x100000f00"。我们可以添加3条这样的调用指令机器码，还剩1字节我们使用nop指令填充（0x90）。需要填充的机器码如下：

```e8 a2ff ffff e89d ffff ffe8 98ff ffff 90```

注意这里的偏移地址计算方法。我们的目标地址是"0x100000f00"，当前rip地址是"0000000100000f5e"，所以第一条hello调用指令偏移地址是"0xffffffa2"，主机序即"0xa2ffffff"，依次类推即可。

![机器码](http://arvinsfj.github.io/public/ctt/documents/testasm/jqm4.png)


到此，我们程序的机器指令修改好了，接下来修改LoadCommand和符号表。


加载命令主要是修改代码段的内存映射地址和main函数的入口地址。这些修改处的地址如何找没什么好方法，靠经验了。不过使用"otool -l test"可以显示加载命令的文本（虽然文本信息跟二进制有很大区别的，但是信息是一致的，可以参考）。加载命令修改如下：

```
代码段开始地址、大小、偏移：
0x1000000d0: b0
0x1000000d8: c1
0x1000000e0: b0
主函数入口地址：
0x100000468: 20
```

运行程序报错，违法的指令。为什么呢？因为我们还有一些东西需要考虑，代码段整体向上移动16字节会影响当前rip的值，而指令的偏移地址没有修正，从而使计算出来的指令目标地址出错。修改很简单，我们修正指令的偏移地址即可。哪些地址受影响呢？库函数调用跳转指令地址和格式化字符串地址。修改如下：

```
putchar函数、格式化字符串、printf函数
0x100000ee5: 8f
0x100000ef2: 82
0x100000f0b: 95
0x100000f12: 95
```

运行程序OK！效果如下：

![修改后的运行效果](http://arvinsfj.github.io/public/ctt/documents/testasm/zxxg.png)


运行命令：otool -tv test

![修改后的汇编码](http://arvinsfj.github.io/public/ctt/documents/testasm/fhb.png)

注意hello函数入口地址应该是"0x100000f00"而现在的hello符号在"0x100000f10"处。虽然不影响程序的运行，但是如何修正呢？这涉及mach-o文件的符号表修改。符号表地址在LC_SYMTAB加载命令中有定义。使用"otool -l test"可以查看文件的加载命令表。可以看到符号表位置是"symoff 8336"也就是"0x100002090"处。使用"nm -x test"可以查看文件的符号表。

![符号表](http://arvinsfj.github.io/public/ctt/documents/testasm/fhaob.png)

可以看到程序的hello符号对应的地址是"0x100000f10"这不符合修改后的程序hello函数地址，需要在vi中修改。修改如下：

```
hello、main、max符号的对应地址
0x1000020a8: 00
0x1000020b8: 20
0x1000020c8: b0
```

运行命令：otool -tv test

![修改后的汇编码](http://arvinsfj.github.io/public/ctt/documents/testasm/fhb1.png)

OK，符号标签位置正确。享受这一刻吧！:）


#### 三、话语

1. 还是很爽的，请多一刻享受
2. 偏移地址的计算很重要，还有就是对程序的理解，特别是程序的位置移动会影响跳转指令和数据资源地址的计算
3. 加载命令段由linker添加，主要定义了程序加载到内存中的位置和链接库等
4. 在机器码层面任何地址都可能是main函数入口地址，只要修改LC_MAIN加载命令（由linker定义）
5. 你还可以做其他的事情，比如自定义函数和调用，不仅仅是增加3条指令，想想和操作空间还是很大的
6. mach-o文件还有其他东西可去了解思考，不过现在这种程度已经是可以修改可执行文件了
7. 可以去熟悉汇编指令跟机器码的对应关系，毕竟x86-64的机器码都是一样的，不管操作系统是什么
8. 想到这是不是感觉可执行文件（机器码）是多么的简洁清爽和直接

---------------------------------------------

END

