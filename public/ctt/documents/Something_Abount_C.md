
# C语言额外的点

> *作者：Arvin 日期：2018年5月31日*

---------------------------------

>BEGIN

记录C语言一些新的点，以前没有遇到的知识。

### 一、思路
---------------------------------

下面是C语言的一段代码：

```

#include <stdio.h>
#include <stdlib.h>

//计算非数组type的大小
#define sizeofb(type)  (size_t)((type*)0+1)
//计算非数组type的大小
#define sizeofb1(type)  (size_t)(&((type*)0)[1])
//计算数组type的大小
#define sizeofa(var)  (size_t)((size_t)(&var+1)-(size_t)(&var))
//计算member在type中的位置
#define offsetof(type, member)  (size_t)(&((type*)0)->member)
//根据member的地址获取type的起始地址
#define containerof(ptr, type, member) ({ const typeof(((type*)0)->member)* __mptr = (ptr); (type*)((char*)__mptr - offsetof(type, member)); })

struct test {
    char a;
    short b;
    char k;
    char s;
};


int main(int argc, char** argv)
{
    int arr[10]; //int a = 0;
    int* point = malloc(10*sizeof(int));
    printf("%d\n", ({int a = 3 , b = 3 > 2; a = 4; b;}));
    printf("%zu\n", sizeofb(struct test));
    printf("%zu\n", sizeofb(int));
    printf("%zu\n", sizeofb(int*));
    printf("%zu\n", sizeofb1(int*));
    printf("%zu\n", sizeofa(arr));
    printf("%zu\n", sizeofa(point));
    printf("%zu\n", offsetof(struct test, k));
    struct test* asd = malloc(sizeof(struct test));
    printf("%p, %p\n", asd, containerof(&asd->k, struct test, k));
    free(asd);
    free(point);
    return 0;
}

```

上面的代码跟我们平常写的C代码不太一样，或者说用常规的思维解释不通的（不能运行的）。比如最上面的几个宏定义，没有定义变量却可以计算类型的大小。main函数里面的符合语句放在圆括号运算符里面求值。typeof宏是gcc的扩展，不是标准C里面的。

    
### 二、我们的代码做了什么？
---------------------------------

```
//计算非数组type的大小
#define sizeofb(type)  (size_t)((type*)0+1)

```

这个宏是计算（非数组类型的）基本类型占用内存的字节数。type是类型，而不是变量。也就是说，它不需要在运行期分配内存，在编译期就可以完成计算，在运行期直接就是一个常数了。这里有一个概念就是编译期计算（由编译器完成）。看上面的有类型转换运算和完成加法运算，这些计算就是在编译器中源代码编译期间完成运算的。这里面隐含了一个信息就是，编译期间编译器定义了各种基本类型的内存占用字节数。编译期运算，我认为就是C语言的“元编程”。ps：上面的宏，不仅仅是简单的文本替换，还做了代码运算。编译器怎么去运算呢？

```
sizeofb(int) 等价于 (size_t)((int*)0+1) = 4
```

宏提供了类型的抽象能力。编译器能运行，首先需要满足C的语法定义。这里就需要明白，强制类型转换运算对常量和变量都是有效的，比如：(int)3.23 = 3; (int)a。指针类型是基本类型，是可以强制类型转换的。其次，需要明白指针除了是变量内存地址之外还隐含了变量的“指针步长”，即变量类型所占用的字节数（由编译器在编译期决定）。针对指针的内存地址编程是运行期业务编程，针对指针的“指针步长”编程是（编译器）编译期类型系统“元编程”。ps：编译器的“元编程”对于我是新的领域。上面就是编译器“元编程”，提取类型的占用字节数。```(int*)0```是将常量0强制转换成```int*```类型的指针常量0x0。然后该指针常量加1，也就是按照int类型的“指针步长”移动该指针，也就是指针的数值增加了4，变成0x4。最后强制转换成size_t类型，即常数4。“指针步长”都是在编译期运算完成。如果表达式仅包含常量的运算（常量表达式），则该运算全部在编译期间完成计算。ps：常量也可以是指针类型，而指针类型可以进行加减运算，可以得出允许进行常量的指针类型加减运算，即“常量指针表达式”。

```
//计算非数组type的大小
#define sizeofb1(type)  (size_t)(&((type*)0)[1])
```

宏sizeofb的另外一种写法，原理类似，用的是```[整数]```运算符。

```
//计算数组type的大小
#define sizeofa(var)  (size_t)((size_t)(&var+1)-(size_t)(&var))

```

上面是计算数组（指针）类型的变量的大小。宏提供了任意变量的抽象。由于传入的是变量var，所以这个宏是在运行期运算的。```&var```获取变量指针，加1，也就是指针的数值（常量，即变量的内存地址）增加变量var类型的“指针步长”的值。表达式返回的就是变量类型的“指针步长”，也就是变量var的大小。如果var是指针变量，由于指针类型的“步长”是8，所以表达式永远返回数值8。如果var是数组变量，由于数组变量即代表数组的指针（起始地址），还代表数组的类型（类似结构体类型，“步长”是整个数组占用的内存大小），所以表达式返回的是数组长度（而非起始指针的长度）。请比较下面的例子：

```
int arr[10]; sizeofa(arr) = 40;
int* arrp = malloc(10*sizeof(int)); sizeof(arrp) = 8;
```

注意：数组变量作为参数传给函数，会丢失数组的类型信息，仅传递数组的起始指针。C中传数组需要传递数组的起始指针和数组的长度。


```
//计算member在type中的位置
#define offsetof(type, member)  (size_t)(&((type*)0)->member)

```

计算结构体type成员member在结构体type中的偏移常量。这个宏是编译期完成运算的。（不涉及变量，全部是常量运算）运算符```->```左边是结构体指针常量或者指针变量，右边必须是结构体成员变量，表达式返回的结构体的成员变量。如果坐标是结构体常量指针0x0，右边是结构体的成员变量，则取该成员变量的指针（数值）就是该成员变量的偏移量。ps：注意运算符```->```的运算规则，类似：*(结构体指针数值+成员偏移量)。

```
//根据member的地址获取type的起始地址
#define containerof(ptr, type, member) ({ const typeof(((type*)0)->member)* __mptr = (ptr); (type*)((char*)__mptr - offsetof(type, member)); })

```

根据结构体成员变量的指针获取结构体变量的指针。基于offsetof的功能，可以计算出成员的偏移量，成员的指针减去偏移量就是结构体变量的指针。typeof是gcc的扩展功能，不是标准C的功能。涉及变量，所以是运行期完成表达式整个的运算，不过偏移量计算是在编译期完成运算的。还有一点是可以通过运算符```()```将复合语句```{exp1; exp2; exp3;}```转换成表达式，同时表达式的返回值是复合语句最后一句exp3表达式的值。如果exp3返回void则会报错。这是一种通用方法，具有普遍性。运算符```()```不仅仅可以改变表达式的运算的优先级（顺序），还可以转换复合语句成表达式。我们可以认为运算符```()```是取表达式或者复合语句返回值的运算符，只是它的优先级比较高。ps：表达式都有返回值，复合语句也有返回值。例如下面的代码：

```
printf("%d\n", ({int a = 3 , b = 3 > 2; a = 4; b;}));
```

是可以正常执行的。

ps: 宏定义、类型的定义（结构体定义等）、函数的声明、全局变量和函数的外部声明等都是在(预)编译期或者连接期提供编译器或连接器信息的，起作用的。在运行期起作用的是，变量的定义、运算符操作和语句（堆栈和代码段在运行期起主要作用）。


```
int* point = malloc(10*sizeof(int));
free(point);
```

point是int类型的指针变量。free函数释放point所指向的内存区域。malloc函数申请内存区域并且返回内存区域的首地址指针，内存区域的大小由malloc函数的参数决定。这两个函数需要用到操作系统的系统调用。从逻辑上，free函数只需要传入首地址指针，它并不知道所要释放内存区域的大小，如何释放呢？个人猜测，在操作系统底层（内存管理模块）应该维护一张内存维护表，记录了malloc系统调用所申请的内存大小和首地址。free系统调用通过这张表和首地址可以查到需要释放的内存区域的大小。进而进行内存“释放”（不一定是真正的释放，有可能将该块内存标记为未使用）。ps：申请的内存区域的内核表示可以理解成一个“内核对象”。像这种类似的“对象”还有进程，文件描述符，套接字等，这种“内核对象”可能是以结构体变量的形式在内核中存在的，返回给用户空间的基本都是唯一的整数常量（win平台叫做“句柄”）。这个用户空间常量代表着内核空间的这些“对象”。这种模式在底层编程中会经常遇到。



### 三、随便说点
---------------------------------

1、C语言可以进行针对类型的编译器“元编程”，注意区分编译期和运行期
2、C运算符除了优先级和结合性，还具有是否需要写操作的性质，具有写操作的运算符的操作数需要包含变量（++、+=等）
3、运算符&虽然只有读取操作，没有写操作，但是操作数也必须是变量（定义是：返回变量的指针）
4、C类型相关的东西，都在编译器进行处理，最终体现在操作指令和分配内存等不同
5、C指针具有值（变量内存地址）和步长（变量类型占用字节数），它们是指针的两个方面（可以针对这两个方面进行编程）
6、变量是对数值的抽象（变量可以代表一类数值），指针是对变量的抽象（指针可以代表一类变量）；抽象不是面向对象的专利
7、一个“句柄”可以代表一个“内核对象”
8、理解C中的常量、变量、类型系统、操作符、表达式、语句（声明、定义、表达式、复合、流程控制、空等）、函数、宏和模块

>END

